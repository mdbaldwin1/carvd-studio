name: Release

on:
  push:
    branches: [main]
  workflow_dispatch: {}

jobs:
  # â”€â”€ Step 1: Determine version and create git tag â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  prepare:
    name: Prepare Release
    # Skip version-bump commits to prevent infinite loops
    if: "!contains(github.event.head_commit.message, 'chore(release):')"
    runs-on: ubuntu-latest
    permissions:
      contents: write
    outputs:
      version: ${{ steps.version.outputs.version }}
      tag: ${{ steps.version.outputs.tag }}
      should_release: ${{ steps.check.outputs.should_release }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get version from package.json
        id: version
        run: |
          VERSION=$(node -p "require('./packages/desktop/package.json').version")
          TAG="v${VERSION}"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "ğŸ“¦ Version: $VERSION (tag: $TAG)"

      - name: Check if version is already released
        id: check
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          TAG="${{ steps.version.outputs.tag }}"

          # Check if this tag already exists
          if gh release view "$TAG" &>/dev/null; then
            echo "âš ï¸  Release $TAG already exists - skipping"
            echo "should_release=false" >> $GITHUB_OUTPUT
          else
            echo "âœ… New version $TAG - proceeding with release"
            echo "should_release=true" >> $GITHUB_OUTPUT
          fi

      - name: Create git tag
        if: steps.check.outputs.should_release == 'true'
        run: |
          TAG="${{ steps.version.outputs.tag }}"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Create tag if it doesn't already exist (idempotent)
          if git rev-parse "$TAG" &>/dev/null; then
            echo "Tag $TAG already exists - reusing"
          else
            git tag "$TAG"
            git push origin "$TAG"
          fi

  # â”€â”€ Step 2: Build and package for each platform â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  build:
    name: Build (${{ matrix.platform }})
    needs: prepare
    if: needs.prepare.outputs.should_release == 'true'
    runs-on: ${{ matrix.os }}

    strategy:
      fail-fast: false
      matrix:
        include:
          - os: macos-latest
            platform: mac
          - os: windows-latest
            platform: win

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.prepare.outputs.tag }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      # Copy app-builder binary to a safe location outside node_modules.
      # electron-builder runs "npm install --production" during packaging,
      # which in a workspace context can delete devDependencies (including
      # app-builder-bin) from the hoisted root node_modules.
      - name: Prepare app-builder binary
        id: app-builder
        shell: bash
        run: |
          BINARY=$(node -p "require('app-builder-bin').appBuilderPath")
          BASENAME=$(basename "$BINARY")
          SAFE_PATH="${RUNNER_TEMP}/${BASENAME}"

          echo "Source: $BINARY"
          echo "Safe copy: $SAFE_PATH"

          cp "$BINARY" "$SAFE_PATH"
          chmod +x "$SAFE_PATH"

          # Verify the copy executes
          "$SAFE_PATH" --help > /dev/null 2>&1 && echo "Binary OK" || {
            echo "ERROR: Binary copy failed to execute"
            exit 1
          }

          echo "safe_path=$SAFE_PATH" >> $GITHUB_OUTPUT

      - name: Setup license key
        run: echo "${{ secrets.LICENSE_PRIVATE_KEY }}" > license-private-key.pem
        working-directory: packages/desktop

      - name: Build desktop app
        run: npm run build --workspace=@carvd/desktop

      - name: Import Apple certificate (macOS only)
        if: matrix.platform == 'mac'
        id: keychain
        env:
          CSC_LINK: ${{ secrets.CSC_LINK }}
          CSC_KEY_PASSWORD: ${{ secrets.CSC_KEY_PASSWORD }}
        run: |
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
          KEYCHAIN_PASSWORD=$(openssl rand -base64 32)

          echo "$CSC_LINK" | base64 --decode > certificate.p12

          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          security import certificate.p12 -k "$KEYCHAIN_PATH" -P "$CSC_KEY_PASSWORD" -T /usr/bin/codesign

          # Install Apple Developer ID intermediate certificates (required for valid chain)
          curl -sL https://www.apple.com/certificateauthority/DeveloperIDG2CA.cer -o DeveloperIDG2CA.cer
          curl -sL https://www.apple.com/certificateauthority/DeveloperIDCA.cer -o DeveloperIDCA.cer
          security import DeveloperIDG2CA.cer -k "$KEYCHAIN_PATH"
          security import DeveloperIDCA.cer -k "$KEYCHAIN_PATH"
          rm DeveloperIDG2CA.cer DeveloperIDCA.cer

          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security list-keychain -d user -s "$KEYCHAIN_PATH"
          rm certificate.p12

          # Output keychain path for the packaging step
          echo "path=$KEYCHAIN_PATH" >> $GITHUB_OUTPUT

      # electron-builder internally runs "npm install --production" in the
      # app directory. In an npm workspace, this detects the root workspace
      # config and wipes devDependencies from the hoisted node_modules.
      # Temporarily strip the workspaces field so npm treats it as standalone.
      - name: Disable workspace detection for packaging
        shell: bash
        run: |
          node -e "
            const fs = require('fs');
            const pkg = JSON.parse(fs.readFileSync('package.json', 'utf-8'));
            delete pkg.workspaces;
            fs.writeFileSync('package.json', JSON.stringify(pkg, null, 2) + '\n');
          "

      - name: Package app (macOS)
        if: matrix.platform == 'mac'
        env:
          # Notarization env vars - uncomment when certificate chain is resolved
          # APPLE_ID: ${{ secrets.APPLE_ID }}
          # APPLE_ID_PASSWORD: ${{ secrets.APPLE_ID_PASSWORD }}
          # APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_ID_PASSWORD }}
          # APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          CSC_KEYCHAIN: ${{ steps.keychain.outputs.path }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          CUSTOM_APP_BUILDER_PATH: ${{ steps.app-builder.outputs.safe_path }}
        working-directory: packages/desktop
        run: npx electron-builder --mac --publish never

      - name: Package app (Windows)
        if: matrix.platform == 'win'
        shell: bash
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          CUSTOM_APP_BUILDER_PATH: ${{ steps.app-builder.outputs.safe_path }}
        working-directory: packages/desktop
        run: npx electron-builder --win --publish never

      - name: Upload artifacts (macOS)
        if: matrix.platform == 'mac'
        uses: actions/upload-artifact@v4
        with:
          name: macos-build
          path: |
            packages/desktop/dist/*.dmg
            packages/desktop/dist/*.zip
            packages/desktop/dist/latest-mac.yml
          retention-days: 7

      - name: Upload artifacts (Windows)
        if: matrix.platform == 'win'
        uses: actions/upload-artifact@v4
        with:
          name: windows-build
          path: |
            packages/desktop/dist/*.exe
            packages/desktop/dist/latest.yml
          retention-days: 7

  # â”€â”€ Step 3: Create GitHub Release with artifacts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  create-release:
    name: Create GitHub Release
    needs: [prepare, build]
    if: needs.prepare.outputs.should_release == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download macOS artifacts
        uses: actions/download-artifact@v4
        with:
          name: macos-build
          path: dist/mac

      - name: Download Windows artifacts
        uses: actions/download-artifact@v4
        with:
          name: windows-build
          path: dist/win

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ needs.prepare.outputs.tag }}
          name: Carvd Studio ${{ needs.prepare.outputs.tag }}
          draft: false
          prerelease: false
          generate_release_notes: true
          files: |
            dist/mac/*.dmg
            dist/mac/*.zip
            dist/mac/latest-mac.yml
            dist/win/*.exe
            dist/win/latest.yml
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # â”€â”€ Step 4: Update Vercel environment variable â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  update-vercel:
    name: Update Vercel Version
    needs: [prepare, create-release]
    if: needs.prepare.outputs.should_release == 'true'
    runs-on: ubuntu-latest

    steps:
      - name: Update VITE_APP_VERSION in Vercel
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
        run: |
          VERSION="${{ needs.prepare.outputs.version }}"

          if [ -z "$VERCEL_TOKEN" ] || [ -z "$VERCEL_PROJECT_ID" ]; then
            echo "âš ï¸  VERCEL_TOKEN or VERCEL_PROJECT_ID not set - skipping"
            exit 0
          fi

          echo "Updating VITE_APP_VERSION to $VERSION..."

          npm install -g vercel

          # Remove existing env var (ignore error if doesn't exist)
          vercel env rm VITE_APP_VERSION production --yes --token "$VERCEL_TOKEN" || true

          # Add new version
          echo "$VERSION" | vercel env add VITE_APP_VERSION production --token "$VERCEL_TOKEN"

          echo "âœ… Updated VITE_APP_VERSION to $VERSION in Vercel"

  # â”€â”€ Step 5: Bump patch version on develop for next release â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  bump-develop:
    name: Bump Version on Develop
    needs: [prepare, create-release]
    if: needs.prepare.outputs.should_release == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Checkout develop branch
        uses: actions/checkout@v4
        with:
          ref: develop
          fetch-depth: 0

      - name: Compute next patch version
        id: next
        run: |
          CURRENT="${{ needs.prepare.outputs.version }}"
          IFS='.' read -ra PARTS <<< "$CURRENT"
          NEXT="${PARTS[0]}.${PARTS[1]}.$((PARTS[2] + 1))"
          echo "version=$NEXT" >> $GITHUB_OUTPUT
          echo "ğŸ“¦ Next development version: $NEXT"

      - name: Create version bump branch and PR
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          NEXT="${{ steps.next.outputs.version }}"
          BRANCH="chore/bump-version-to-${NEXT}"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git checkout -b "$BRANCH"

          # Update version in desktop package.json
          node -e "
            const fs = require('fs');
            const pkg = JSON.parse(fs.readFileSync('packages/desktop/package.json', 'utf-8'));
            pkg.version = '${NEXT}';
            fs.writeFileSync('packages/desktop/package.json', JSON.stringify(pkg, null, 2) + '\n');
          "

          git add packages/desktop/package.json
          git commit -m "chore(release): bump version to ${NEXT} for next development cycle"

          git push origin "$BRANCH"

          gh pr create \
            --base develop \
            --head "$BRANCH" \
            --title "chore: bump version to ${NEXT}" \
            --body "Automated version bump after release of v${{ needs.prepare.outputs.version }}. Merge when ready to start the next development cycle."

  # â”€â”€ Summary â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  summary:
    name: Release Summary
    needs: [prepare, build, create-release, update-vercel, bump-develop]
    if: always() && needs.prepare.outputs.should_release == 'true'
    runs-on: ubuntu-latest

    steps:
      - name: Print summary
        run: |
          echo "## Release Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Step | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Version | **${{ needs.prepare.outputs.tag }}** |" >> $GITHUB_STEP_SUMMARY
          echo "| Build | ${{ needs.build.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| GitHub Release | ${{ needs.create-release.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Vercel Update | ${{ needs.update-vercel.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Develop Bump | ${{ needs.bump-develop.result }} |" >> $GITHUB_STEP_SUMMARY

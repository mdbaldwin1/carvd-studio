/**
 * PDF Export utilities for cutting diagrams, cut lists, shopping lists, and project reports
 * Uses jsPDF to programmatically draw diagrams and tables
 */

import jsPDF from 'jspdf';
import { CutList, CutInstruction, StockBoard, CustomShoppingItem } from '../types';
import { formatMeasurementWithUnit } from './fractions';
import { logger } from './logger';

interface ExportOptions {
  projectName: string;
  units: 'imperial' | 'metric';
}

interface ProjectReportOptions extends ExportOptions {
  projectNotes?: string;
  thumbnailData?: string; // Base64 PNG data URL
  customShoppingItems: CustomShoppingItem[];
}

// Grouped cut instruction for parts with identical dimensions
interface GroupedCutInstruction {
  key: string;
  cutLength: number;
  cutWidth: number;
  thickness: number;
  stockId: string;
  stockName: string;
  grainSensitive: boolean;
  isGlueUp: boolean;
  quantity: number;
  items: CutInstruction[];
}

const WATERMARK_TEXT = 'Generated by Carvd Studio - carvd-studio.com';
const WATERMARK_LOGO_LOAD_TIMEOUT_MS = 1200;
let watermarkLogoPromise: Promise<string | null> | null = null;

async function loadSvgAsPngDataUrl(path: string, targetHeight: number): Promise<string | null> {
  try {
    const img = new window.Image();
    img.decoding = 'async';
    await new Promise<void>((resolve, reject) => {
      const timeoutId = window.setTimeout(() => {
        cleanup();
        reject(new Error(`Timed out loading image: ${path}`));
      }, WATERMARK_LOGO_LOAD_TIMEOUT_MS);

      const cleanup = () => {
        window.clearTimeout(timeoutId);
        img.onload = null;
        img.onerror = null;
      };

      img.onload = () => {
        cleanup();
        resolve();
      };
      img.onerror = () => {
        cleanup();
        reject(new Error(`Failed to load image: ${path}`));
      };
      img.src = path;
    });

    if (img.width <= 0 || img.height <= 0) {
      return null;
    }

    const scale = targetHeight / img.height;
    const width = Math.max(1, Math.round(img.width * scale));
    const height = Math.max(1, Math.round(targetHeight));

    // Render at higher internal resolution so the image remains sharp in PDFs.
    const renderScale = Math.max(4, Math.ceil((window.devicePixelRatio || 1) * 3));

    const canvas = document.createElement('canvas');
    canvas.width = width * renderScale;
    canvas.height = height * renderScale;

    const ctx = canvas.getContext('2d');
    if (!ctx) return null;
    ctx.scale(renderScale, renderScale);
    ctx.drawImage(img, 0, 0, width, height);

    return canvas.toDataURL('image/png');
  } catch {
    return null;
  }
}

async function getWatermarkLogoDataUrl(): Promise<string | null> {
  if (!watermarkLogoPromise) {
    // Horizontal lockup renders best as a compact footer watermark on white PDF pages.
    watermarkLogoPromise = loadSvgAsPngDataUrl('/branding/CarvdStudio-Horizontal.svg', 20);
  }
  return watermarkLogoPromise;
}

/**
 * Add watermark to bottom of page
 */
function addWatermark(doc: jsPDF, pageWidth: number, pageHeight: number, logoDataUrl?: string | null): void {
  const baselineY = pageHeight - 15;
  doc.setFontSize(8);
  doc.setTextColor(150, 150, 150);

  if (!logoDataUrl) {
    doc.text(WATERMARK_TEXT, pageWidth / 2, baselineY, { align: 'center' });
    return;
  }

  const logoHeight = 12;
  let logoWidth = 72;
  try {
    const imageProps = doc.getImageProperties(logoDataUrl);
    if (imageProps.width > 0 && imageProps.height > 0) {
      logoWidth = (logoHeight * imageProps.width) / imageProps.height;
    }
  } catch {
    // Fallback to default dimensions if image metadata isn't available.
  }
  const gap = 7;
  const textWidth = doc.getTextWidth(WATERMARK_TEXT);
  const totalWidth = logoWidth + gap + textWidth;
  const startX = (pageWidth - totalWidth) / 2;

  doc.addImage(logoDataUrl, 'PNG', startX, baselineY - logoHeight + 2, logoWidth, logoHeight);
  doc.text(WATERMARK_TEXT, startX + logoWidth + gap, baselineY);
}

function drawBoardDiagram(
  doc: jsPDF,
  board: StockBoard,
  stockName: string,
  units: 'imperial' | 'metric',
  area: { x: number; y: number; width: number; height: number }
): void {
  const headerHeight = 38;
  doc.setFontSize(12);
  doc.setFont('helvetica', 'bold');
  doc.setTextColor(0, 0, 0);
  doc.text(`${stockName} - Board #${board.boardIndex}`, area.x, area.y + 14);

  doc.setFontSize(9);
  doc.setFont('helvetica', 'normal');
  const dims = `${formatMeasurementWithUnit(board.stockLength, units)} × ${formatMeasurementWithUnit(board.stockWidth, units)}`;
  doc.text(dims, area.x, area.y + 30);
  doc.text(
    `${board.placements.length} part${board.placements.length !== 1 ? 's' : ''} | ${board.utilizationPercent.toFixed(1)}% utilization`,
    area.x + area.width - 150,
    area.y + 14
  );

  const diagramTop = area.y + headerHeight;
  const diagramAreaHeight = Math.max(40, area.height - headerHeight);
  const diagramAreaWidth = area.width;
  const scaleX = diagramAreaWidth / board.stockLength;
  const scaleY = diagramAreaHeight / board.stockWidth;
  const scale = Math.min(scaleX, scaleY);

  const diagramWidth = board.stockLength * scale;
  const diagramHeight = board.stockWidth * scale;
  const diagramX = area.x + (diagramAreaWidth - diagramWidth) / 2;
  const diagramY = diagramTop + (diagramAreaHeight - diagramHeight) / 2;

  doc.setDrawColor(60, 60, 60);
  doc.setLineWidth(2);
  doc.setFillColor(245, 240, 230);
  doc.rect(diagramX, diagramY, diagramWidth, diagramHeight, 'FD');

  for (const placement of board.placements) {
    const x = diagramX + placement.x * scale;
    const y = diagramY + placement.y * scale;
    const w = placement.width * scale;
    const h = placement.height * scale;

    doc.setFillColor(210, 185, 135);
    doc.setDrawColor(100, 70, 40);
    doc.setLineWidth(1);
    doc.rect(x, y, w, h, 'FD');

    const label = placement.partName;
    const labelDims = `${formatMeasurementWithUnit(placement.width, units)} × ${formatMeasurementWithUnit(placement.height, units)}`;
    const maxFontSize = 12;
    const minFontSize = 6;
    const fontSizeByWidth = w / 8;
    const fontSizeByHeight = h / 3;
    const fontSize = Math.max(minFontSize, Math.min(maxFontSize, fontSizeByWidth, fontSizeByHeight));

    doc.setFontSize(fontSize);
    doc.setFont('helvetica', 'bold');
    doc.setTextColor(50, 35, 20);

    if (w > 25 && h > 15) {
      const textWidth = doc.getTextWidth(label);
      const textX = x + (w - textWidth) / 2;
      const textY = y + h / 2;

      doc.text(label, textX, textY);

      if (h > 30) {
        doc.setFontSize(Math.max(5, fontSize * 0.7));
        doc.setFont('helvetica', 'normal');
        const dimsWidth = doc.getTextWidth(labelDims);
        doc.text(labelDims, x + (w - dimsWidth) / 2, textY + fontSize);
      }
    }
  }
}

/**
 * Group identical cut instructions together
 */
function groupCutInstructions(instructions: CutInstruction[]): GroupedCutInstruction[] {
  const groups = new Map<string, GroupedCutInstruction>();

  for (const inst of instructions) {
    const key = `${inst.cutLength}-${inst.cutWidth}-${inst.thickness}-${inst.stockId}-${inst.grainSensitive}-${inst.isGlueUp}`;

    const existing = groups.get(key);
    if (existing) {
      existing.quantity++;
      existing.items.push(inst);
    } else {
      groups.set(key, {
        key,
        cutLength: inst.cutLength,
        cutWidth: inst.cutWidth,
        thickness: inst.thickness,
        stockId: inst.stockId,
        stockName: inst.stockName,
        grainSensitive: inst.grainSensitive,
        isGlueUp: inst.isGlueUp,
        quantity: 1,
        items: [inst]
      });
    }
  }

  return Array.from(groups.values());
}

/**
 * Helper to escape CSV values (double quotes become doubled)
 */
function csvEscape(value: string): string {
  return `"${value.replace(/"/g, '""')}"`;
}

/**
 * Generate CSV header comment with watermark
 */
export function getCsvHeader(): string {
  return `# Generated by Carvd Studio\n# https://carvd-studio.com\n# Date: ${new Date().toLocaleString()}\n\n`;
}

/**
 * Export cut list to PDF
 */
export async function exportCutListToPdf(
  cutList: CutList,
  options: ExportOptions
): Promise<{ success: boolean; filePath?: string; error?: string; canceled?: boolean }> {
  const { projectName, units } = options;

  const doc = new jsPDF({
    orientation: 'portrait',
    unit: 'pt',
    format: 'letter'
  });

  const pageWidth = doc.internal.pageSize.getWidth();
  const pageHeight = doc.internal.pageSize.getHeight();
  const margin = 40;
  const contentWidth = pageWidth - margin * 2;
  const watermarkLogoDataUrl = await getWatermarkLogoDataUrl();

  // Title
  doc.setFontSize(20);
  doc.setFont('helvetica', 'bold');
  doc.setTextColor(0, 0, 0);
  doc.text(projectName || 'Cut List', margin, margin + 25);

  doc.setFontSize(10);
  doc.setFont('helvetica', 'normal');
  doc.text(`Generated: ${new Date().toLocaleDateString()}`, margin, margin + 42);
  doc.text(`${cutList.instructions.length} parts, ${cutList.stockBoards.length} boards needed`, margin, margin + 55);

  // Group instructions
  const grouped = groupCutInstructions(cutList.instructions);

  // Table header
  let y = margin + 80;
  const colWidths = [35, 150, 70, 70, 60, 100]; // Qty, Part Names, Length, Width, Thickness, Stock
  const colX = [margin, margin + 35, margin + 185, margin + 255, margin + 325, margin + 385];

  doc.setFillColor(240, 240, 240);
  doc.rect(margin, y - 12, contentWidth, 18, 'F');
  doc.setFontSize(9);
  doc.setFont('helvetica', 'bold');
  doc.text('Qty', colX[0], y);
  doc.text('Part Names', colX[1], y);
  doc.text('Length', colX[2], y);
  doc.text('Width', colX[3], y);
  doc.text('Thickness', colX[4], y);
  doc.text('Stock', colX[5], y);

  y += 18;
  doc.setFont('helvetica', 'normal');
  doc.setFontSize(9);

  for (const group of grouped) {
    // Check for page break
    if (y > pageHeight - 60) {
      addWatermark(doc, pageWidth, pageHeight, watermarkLogoDataUrl);
      doc.addPage();
      y = margin + 20;
    }

    // Part names (join if multiple)
    const partNames = group.items.map((i) => i.partName).join(', ');
    const notes: string[] = [];
    if (group.grainSensitive) notes.push('Grain');
    if (group.isGlueUp) notes.push('Glue-up');

    doc.text(group.quantity.toString(), colX[0], y);

    // Truncate part names if too long
    const maxNameWidth = colWidths[1] - 5;
    let displayName = partNames;
    while (doc.getTextWidth(displayName) > maxNameWidth && displayName.length > 10) {
      displayName = displayName.substring(0, displayName.length - 4) + '...';
    }
    doc.text(displayName, colX[1], y);

    doc.text(formatMeasurementWithUnit(group.cutLength, units), colX[2], y);
    doc.text(formatMeasurementWithUnit(group.cutWidth, units), colX[3], y);
    doc.text(formatMeasurementWithUnit(group.thickness, units), colX[4], y);

    // Stock name with notes
    const stockWithNotes = notes.length > 0 ? `${group.stockName} (${notes.join(', ')})` : group.stockName;
    let displayStock = stockWithNotes;
    while (doc.getTextWidth(displayStock) > 125 && displayStock.length > 10) {
      displayStock = displayStock.substring(0, displayStock.length - 4) + '...';
    }
    doc.text(displayStock, colX[5], y);

    y += 16;
  }

  addWatermark(doc, pageWidth, pageHeight, watermarkLogoDataUrl);

  // Save
  try {
    const defaultFileName = `${projectName || 'cut-list'}-parts.pdf`;
    const result = await window.electronAPI.showSaveDialog({
      defaultPath: defaultFileName,
      filters: [{ name: 'PDF Files', extensions: ['pdf'] }]
    });

    if (result.canceled || !result.filePath) {
      return { success: false, canceled: true };
    }

    const pdfArrayBuffer = doc.output('arraybuffer');
    const uint8Array = new Uint8Array(pdfArrayBuffer);
    const numberArray = Array.from(uint8Array);

    await window.electronAPI.writeBinaryFile(result.filePath, numberArray);

    return { success: true, filePath: result.filePath };
  } catch (error) {
    logger.error('Cut list PDF export error:', error);
    return { success: false, error: String(error) };
  }
}

/**
 * Export shopping list to PDF
 */
export async function exportShoppingListToPdf(
  cutList: CutList,
  customShoppingItems: CustomShoppingItem[],
  options: ExportOptions
): Promise<{ success: boolean; filePath?: string; error?: string; canceled?: boolean }> {
  const { projectName, units } = options;

  const doc = new jsPDF({
    orientation: 'portrait',
    unit: 'pt',
    format: 'letter'
  });

  const pageWidth = doc.internal.pageSize.getWidth();
  const pageHeight = doc.internal.pageSize.getHeight();
  const margin = 40;
  const contentWidth = pageWidth - margin * 2;
  const watermarkLogoDataUrl = await getWatermarkLogoDataUrl();

  // Title
  doc.setFontSize(20);
  doc.setFont('helvetica', 'bold');
  doc.setTextColor(0, 0, 0);
  doc.text(`${projectName || 'Project'} - Shopping List`, margin, margin + 25);

  doc.setFontSize(10);
  doc.setFont('helvetica', 'normal');
  doc.text(`Generated: ${new Date().toLocaleDateString()}`, margin, margin + 42);

  let y = margin + 70;

  // Lumber & Sheet Goods Section
  doc.setFontSize(14);
  doc.setFont('helvetica', 'bold');
  doc.text('Lumber & Sheet Goods', margin, y);
  y += 25;

  // Table header
  doc.setFillColor(240, 240, 240);
  doc.rect(margin, y - 12, contentWidth, 18, 'F');
  doc.setFontSize(9);
  doc.text('Stock', margin + 5, y);
  doc.text('Dimensions', margin + 160, y);
  doc.text('Qty', margin + 320, y);
  doc.text('Unit Price', margin + 370, y);
  doc.text('Total', margin + 450, y);
  y += 18;

  doc.setFont('helvetica', 'normal');

  for (const summary of cutList.statistics.byStock) {
    if (y > pageHeight - 80) {
      addWatermark(doc, pageWidth, pageHeight, watermarkLogoDataUrl);
      doc.addPage();
      y = margin + 20;
    }

    const dims = `${formatMeasurementWithUnit(summary.stockLength, units)} x ${formatMeasurementWithUnit(summary.stockWidth, units)} x ${formatMeasurementWithUnit(summary.stockThickness, units)}`;
    const unitPrice =
      summary.pricingUnit === 'board_foot'
        ? `$${summary.pricePerUnit.toFixed(2)}/bf`
        : `$${summary.pricePerUnit.toFixed(2)}/ea`;

    doc.text(summary.stockName, margin + 5, y);
    doc.text(dims, margin + 160, y);
    doc.text(summary.boardsNeeded.toString(), margin + 320, y);
    doc.text(unitPrice, margin + 370, y);
    doc.text(`$${summary.cost.toFixed(2)}`, margin + 450, y);
    y += 16;
  }

  // Lumber subtotal
  y += 5;
  doc.setFont('helvetica', 'bold');
  doc.text('Lumber Subtotal:', margin + 350, y);
  doc.text(`$${cutList.statistics.estimatedCost.toFixed(2)}`, margin + 450, y);
  y += 25;

  // Custom items section
  if (customShoppingItems.length > 0) {
    doc.setFontSize(14);
    doc.text('Other Items', margin, y);
    y += 25;

    // Table header
    doc.setFillColor(240, 240, 240);
    doc.rect(margin, y - 12, contentWidth, 18, 'F');
    doc.setFontSize(9);
    doc.text('Item', margin + 5, y);
    doc.text('Description', margin + 180, y);
    doc.text('Qty', margin + 320, y);
    doc.text('Unit Price', margin + 370, y);
    doc.text('Total', margin + 450, y);
    y += 18;

    doc.setFont('helvetica', 'normal');

    let customTotal = 0;
    for (const item of customShoppingItems) {
      if (y > pageHeight - 80) {
        addWatermark(doc, pageWidth, pageHeight, watermarkLogoDataUrl);
        doc.addPage();
        y = margin + 20;
      }

      const itemTotal = item.quantity * item.unitPrice;
      customTotal += itemTotal;

      doc.text(item.name, margin + 5, y);
      doc.text(item.description || '', margin + 180, y);
      doc.text(item.quantity.toString(), margin + 320, y);
      doc.text(`$${item.unitPrice.toFixed(2)}`, margin + 370, y);
      doc.text(`$${itemTotal.toFixed(2)}`, margin + 450, y);
      y += 16;
    }

    // Custom items subtotal
    y += 5;
    doc.setFont('helvetica', 'bold');
    doc.text('Other Items Subtotal:', margin + 330, y);
    doc.text(`$${customTotal.toFixed(2)}`, margin + 450, y);
    y += 25;
  }

  // Grand total
  const customTotal = customShoppingItems.reduce((sum, item) => sum + item.quantity * item.unitPrice, 0);
  const grandTotal = cutList.statistics.estimatedCost + customTotal;

  doc.setFontSize(12);
  doc.setFont('helvetica', 'bold');
  doc.setFillColor(230, 230, 230);
  doc.rect(margin + 300, y - 12, contentWidth - 300, 22, 'F');
  doc.text('GRAND TOTAL:', margin + 330, y + 2);
  doc.text(`$${grandTotal.toFixed(2)}`, margin + 450, y + 2);

  addWatermark(doc, pageWidth, pageHeight, watermarkLogoDataUrl);

  // Save
  try {
    const defaultFileName = `${projectName || 'Untitled'}-shopping-list.pdf`;
    const result = await window.electronAPI.showSaveDialog({
      defaultPath: defaultFileName,
      filters: [{ name: 'PDF Files', extensions: ['pdf'] }]
    });

    if (result.canceled || !result.filePath) {
      return { success: false, canceled: true };
    }

    const pdfArrayBuffer = doc.output('arraybuffer');
    const uint8Array = new Uint8Array(pdfArrayBuffer);
    const numberArray = Array.from(uint8Array);

    await window.electronAPI.writeBinaryFile(result.filePath, numberArray);

    return { success: true, filePath: result.filePath };
  } catch (error) {
    logger.error('Shopping list PDF export error:', error);
    return { success: false, error: String(error) };
  }
}

/**
 * Export comprehensive project report to PDF
 * Includes: cover page with thumbnail, cut list, cutting diagrams, shopping list
 */
export async function exportProjectReportToPdf(
  cutList: CutList,
  options: ProjectReportOptions
): Promise<{ success: boolean; filePath?: string; error?: string; canceled?: boolean }> {
  const { projectName, projectNotes, thumbnailData, units, customShoppingItems } = options;

  const doc = new jsPDF({
    orientation: 'portrait',
    unit: 'pt',
    format: 'letter'
  });

  const pageWidth = doc.internal.pageSize.getWidth();
  const pageHeight = doc.internal.pageSize.getHeight();
  const margin = 40;
  const contentWidth = pageWidth - margin * 2;
  const watermarkLogoDataUrl = await getWatermarkLogoDataUrl();

  // ============ COVER PAGE ============
  let y = margin + 40;

  // Project thumbnail (if available)
  if (thumbnailData) {
    try {
      const imgWidth = 400;
      const imgHeight = 250;
      const imgX = (pageWidth - imgWidth) / 2;
      doc.addImage(thumbnailData, 'PNG', imgX, y, imgWidth, imgHeight);
      y += imgHeight + 30;
    } catch (e) {
      logger.warn('Failed to add thumbnail to PDF:', e);
      y += 20;
    }
  }

  // Project title
  doc.setFontSize(28);
  doc.setFont('helvetica', 'bold');
  doc.setTextColor(0, 0, 0);
  doc.text(projectName || 'Project Report', pageWidth / 2, y, { align: 'center' });
  y += 35;

  // Subtitle
  doc.setFontSize(12);
  doc.setFont('helvetica', 'normal');
  doc.setTextColor(100, 100, 100);
  doc.text('Cut List & Material Report', pageWidth / 2, y, { align: 'center' });
  y += 25;

  doc.setFontSize(10);
  doc.text(`Generated: ${new Date().toLocaleDateString()}`, pageWidth / 2, y, { align: 'center' });
  y += 40;

  // Project notes/description
  if (projectNotes) {
    doc.setFontSize(11);
    doc.setTextColor(60, 60, 60);
    doc.setFont('helvetica', 'italic');

    const splitNotes = doc.splitTextToSize(projectNotes, contentWidth - 40);
    doc.text(splitNotes, margin + 20, y);
    y += splitNotes.length * 14 + 20;
  }

  // Quick stats box
  y = Math.max(y, pageHeight - 200);
  doc.setFillColor(245, 245, 245);
  doc.roundedRect(margin, y, contentWidth, 100, 8, 8, 'F');

  doc.setFontSize(10);
  doc.setFont('helvetica', 'bold');
  doc.setTextColor(0, 0, 0);

  const statsY = y + 25;
  const col1 = margin + 30;
  const col2 = margin + 150;
  const col3 = margin + 300;
  const col4 = margin + 430;

  doc.text('Parts:', col1, statsY);
  doc.text('Boards:', col2, statsY);
  doc.text('Board Feet:', col3, statsY);
  doc.text('Est. Cost:', col4, statsY);

  doc.setFont('helvetica', 'normal');
  doc.setFontSize(14);
  doc.text(cutList.statistics.totalParts.toString(), col1, statsY + 20);
  doc.text(cutList.statistics.totalStockBoards.toString(), col2, statsY + 20);
  doc.text(cutList.statistics.totalBoardFeet.toFixed(2), col3, statsY + 20);

  const customTotal = customShoppingItems.reduce((sum, item) => sum + item.quantity * item.unitPrice, 0);
  const grandTotal = cutList.statistics.estimatedCost + customTotal;
  doc.text(`$${grandTotal.toFixed(2)}`, col4, statsY + 20);

  doc.setFontSize(9);
  doc.setTextColor(100, 100, 100);
  doc.text(`${cutList.statistics.wastePercentage.toFixed(1)}% waste`, col3, statsY + 38);

  addWatermark(doc, pageWidth, pageHeight, watermarkLogoDataUrl);

  // ============ CUT LIST PAGE ============
  doc.addPage();
  y = margin + 20;

  doc.setFontSize(18);
  doc.setFont('helvetica', 'bold');
  doc.setTextColor(0, 0, 0);
  doc.text('Cut List', margin, y);
  y += 30;

  // Group instructions
  const grouped = groupCutInstructions(cutList.instructions);

  // Table header
  const colWidths2 = [35, 145, 68, 68, 60, 95];
  const colX2 = [margin, margin + 35, margin + 180, margin + 248, margin + 316, margin + 376];

  doc.setFillColor(240, 240, 240);
  doc.rect(margin, y - 12, contentWidth, 18, 'F');
  doc.setFontSize(9);
  doc.setFont('helvetica', 'bold');
  doc.text('Qty', colX2[0], y);
  doc.text('Part Names', colX2[1], y);
  doc.text('Length', colX2[2], y);
  doc.text('Width', colX2[3], y);
  doc.text('Thick', colX2[4], y);
  doc.text('Stock', colX2[5], y);

  y += 18;
  doc.setFont('helvetica', 'normal');
  doc.setFontSize(8);

  for (const group of grouped) {
    if (y > pageHeight - 50) {
      addWatermark(doc, pageWidth, pageHeight, watermarkLogoDataUrl);
      doc.addPage();
      y = margin + 20;
    }

    const partNames = group.items.map((i) => i.partName).join(', ');
    const notes: string[] = [];
    if (group.grainSensitive) notes.push('Grain');
    if (group.isGlueUp) notes.push('Glue-up');

    doc.text(group.quantity.toString(), colX2[0], y);

    let displayName = partNames;
    while (doc.getTextWidth(displayName) > colWidths2[1] - 5 && displayName.length > 10) {
      displayName = displayName.substring(0, displayName.length - 4) + '...';
    }
    doc.text(displayName, colX2[1], y);
    doc.text(formatMeasurementWithUnit(group.cutLength, units), colX2[2], y);
    doc.text(formatMeasurementWithUnit(group.cutWidth, units), colX2[3], y);
    doc.text(formatMeasurementWithUnit(group.thickness, units), colX2[4], y);

    const stockWithNotes = notes.length > 0 ? `${group.stockName} (${notes.join(', ')})` : group.stockName;
    let displayStock = stockWithNotes;
    while (doc.getTextWidth(displayStock) > colWidths2[5] - 5 && displayStock.length > 10) {
      displayStock = displayStock.substring(0, displayStock.length - 4) + '...';
    }
    doc.text(displayStock, colX2[5], y);

    y += 14;
  }

  addWatermark(doc, pageWidth, pageHeight, watermarkLogoDataUrl);

  // ============ CUTTING DIAGRAMS PAGES ============
  // Group boards by stock
  const boardsByStock = new Map<string, StockBoard[]>();
  for (const board of cutList.stockBoards) {
    const existing = boardsByStock.get(board.stockId) || [];
    existing.push(board);
    boardsByStock.set(board.stockId, existing);
  }

  // Draw boards (two per landscape page)
  for (const [, boards] of boardsByStock) {
    const stockName = boards[0].stockName;

    for (let i = 0; i < boards.length; i += 2) {
      doc.addPage('landscape');

      const lpageWidth = doc.internal.pageSize.getWidth();
      const lpageHeight = doc.internal.pageSize.getHeight();
      const lmargin = 40;
      const lcontentWidth = lpageWidth - lmargin * 2;
      const lcontentHeight = lpageHeight - lmargin * 2 - 25;
      const rowGap = 20;
      const rowHeight = (lcontentHeight - rowGap) / 2;

      drawBoardDiagram(doc, boards[i], stockName, units, {
        x: lmargin,
        y: lmargin,
        width: lcontentWidth,
        height: rowHeight
      });

      if (boards[i + 1]) {
        drawBoardDiagram(doc, boards[i + 1], stockName, units, {
          x: lmargin,
          y: lmargin + rowHeight + rowGap,
          width: lcontentWidth,
          height: rowHeight
        });
      }

      addWatermark(doc, lpageWidth, lpageHeight, watermarkLogoDataUrl);
    }
  }

  // ============ SHOPPING LIST PAGE ============
  doc.addPage('portrait');
  y = margin + 20;

  doc.setFontSize(18);
  doc.setFont('helvetica', 'bold');
  doc.setTextColor(0, 0, 0);
  doc.text('Shopping List', margin, y);
  y += 30;

  // Lumber section
  doc.setFontSize(12);
  doc.setFont('helvetica', 'bold');
  doc.text('Lumber & Sheet Goods', margin, y);
  y += 20;

  doc.setFillColor(240, 240, 240);
  doc.rect(margin, y - 12, contentWidth, 18, 'F');
  doc.setFontSize(9);
  doc.text('Stock', margin + 5, y);
  doc.text('Dimensions', margin + 150, y);
  doc.text('Qty', margin + 310, y);
  doc.text('Unit Price', margin + 360, y);
  doc.text('Total', margin + 450, y);
  y += 18;

  doc.setFont('helvetica', 'normal');

  for (const summary of cutList.statistics.byStock) {
    if (y > pageHeight - 100) {
      addWatermark(doc, pageWidth, pageHeight, watermarkLogoDataUrl);
      doc.addPage();
      y = margin + 20;
    }

    const dims = `${formatMeasurementWithUnit(summary.stockLength, units)} x ${formatMeasurementWithUnit(summary.stockWidth, units)} x ${formatMeasurementWithUnit(summary.stockThickness, units)}`;
    const unitPrice =
      summary.pricingUnit === 'board_foot'
        ? `$${summary.pricePerUnit.toFixed(2)}/bf`
        : `$${summary.pricePerUnit.toFixed(2)}/ea`;

    doc.text(summary.stockName, margin + 5, y);
    doc.text(dims, margin + 150, y);
    doc.text(summary.boardsNeeded.toString(), margin + 310, y);
    doc.text(unitPrice, margin + 360, y);
    doc.text(`$${summary.cost.toFixed(2)}`, margin + 450, y);
    y += 16;
  }

  y += 5;
  doc.setFont('helvetica', 'bold');
  doc.text('Subtotal:', margin + 370, y);
  doc.text(`$${cutList.statistics.estimatedCost.toFixed(2)}`, margin + 450, y);
  y += 25;

  // Custom items
  if (customShoppingItems.length > 0) {
    doc.setFontSize(12);
    doc.text('Other Items', margin, y);
    y += 20;

    doc.setFillColor(240, 240, 240);
    doc.rect(margin, y - 12, contentWidth, 18, 'F');
    doc.setFontSize(9);
    doc.text('Item', margin + 5, y);
    doc.text('Description', margin + 170, y);
    doc.text('Qty', margin + 310, y);
    doc.text('Unit Price', margin + 360, y);
    doc.text('Total', margin + 450, y);
    y += 18;

    doc.setFont('helvetica', 'normal');

    for (const item of customShoppingItems) {
      if (y > pageHeight - 80) {
        addWatermark(doc, pageWidth, pageHeight, watermarkLogoDataUrl);
        doc.addPage();
        y = margin + 20;
      }

      const itemTotal = item.quantity * item.unitPrice;
      doc.text(item.name, margin + 5, y);
      doc.text(item.description || '', margin + 170, y);
      doc.text(item.quantity.toString(), margin + 310, y);
      doc.text(`$${item.unitPrice.toFixed(2)}`, margin + 360, y);
      doc.text(`$${itemTotal.toFixed(2)}`, margin + 450, y);
      y += 16;
    }

    y += 5;
    doc.setFont('helvetica', 'bold');
    const otherTotal = customShoppingItems.reduce((sum, item) => sum + item.quantity * item.unitPrice, 0);
    doc.text('Subtotal:', margin + 370, y);
    doc.text(`$${otherTotal.toFixed(2)}`, margin + 450, y);
    y += 25;
  }

  // Grand total
  doc.setFontSize(11);
  doc.setFillColor(230, 230, 230);
  doc.rect(margin + 300, y - 12, contentWidth - 300, 22, 'F');
  doc.text('GRAND TOTAL:', margin + 340, y + 2);
  doc.text(`$${grandTotal.toFixed(2)}`, margin + 450, y + 2);

  addWatermark(doc, pageWidth, pageHeight, watermarkLogoDataUrl);

  // Save
  try {
    const defaultFileName = `${projectName || 'project'}-report.pdf`;
    const result = await window.electronAPI.showSaveDialog({
      defaultPath: defaultFileName,
      filters: [{ name: 'PDF Files', extensions: ['pdf'] }]
    });

    if (result.canceled || !result.filePath) {
      return { success: false, canceled: true };
    }

    const pdfArrayBuffer = doc.output('arraybuffer');
    const uint8Array = new Uint8Array(pdfArrayBuffer);
    const numberArray = Array.from(uint8Array);

    await window.electronAPI.writeBinaryFile(result.filePath, numberArray);

    return { success: true, filePath: result.filePath };
  } catch (error) {
    logger.error('Project report PDF export error:', error);
    return { success: false, error: String(error) };
  }
}

/**
 * Export cutting diagrams to PDF
 * Draws each stock board with its placed parts
 */
export async function exportDiagramsToPdf(
  cutList: CutList,
  options: ExportOptions
): Promise<{ success: boolean; filePath?: string; error?: string; canceled?: boolean }> {
  const { projectName, units } = options;

  // Group boards by stock
  const boardsByStock = new Map<string, StockBoard[]>();
  for (const board of cutList.stockBoards) {
    const existing = boardsByStock.get(board.stockId) || [];
    existing.push(board);
    boardsByStock.set(board.stockId, existing);
  }

  // Create PDF in landscape for better diagram fit
  const doc = new jsPDF({
    orientation: 'landscape',
    unit: 'pt', // points for precise positioning
    format: 'letter'
  });

  const pageWidth = doc.internal.pageSize.getWidth();
  const pageHeight = doc.internal.pageSize.getHeight();
  const margin = 40;
  const contentWidth = pageWidth - margin * 2;
  const watermarkLogoDataUrl = await getWatermarkLogoDataUrl();

  // Title
  doc.setFontSize(18);
  doc.setFont('helvetica', 'bold');
  doc.text(`${projectName} - Cutting Diagrams`, margin, margin + 20);

  doc.setFontSize(10);
  doc.setFont('helvetica', 'normal');
  doc.text(`Generated: ${new Date().toLocaleDateString()}`, margin, margin + 35);
  doc.text(
    `Total: ${cutList.stockBoards.length} board${cutList.stockBoards.length !== 1 ? 's' : ''} needed`,
    margin,
    margin + 48
  );

  addWatermark(doc, pageWidth, pageHeight, watermarkLogoDataUrl);

  const headerHeight = 50; // Space for title section

  // Draw each stock group - two boards per page
  for (const [, boards] of boardsByStock) {
    const stockName = boards[0].stockName;

    for (let i = 0; i < boards.length; i += 2) {
      doc.addPage();

      const diagramAreaTop = margin + headerHeight;
      const diagramAreaHeight = pageHeight - diagramAreaTop - margin - 30;
      const rowGap = 20;
      const rowHeight = (diagramAreaHeight - rowGap) / 2;

      drawBoardDiagram(doc, boards[i], stockName, units, {
        x: margin,
        y: diagramAreaTop,
        width: contentWidth,
        height: rowHeight
      });

      if (boards[i + 1]) {
        drawBoardDiagram(doc, boards[i + 1], stockName, units, {
          x: margin,
          y: diagramAreaTop + rowHeight + rowGap,
          width: contentWidth,
          height: rowHeight
        });
      }

      addWatermark(doc, pageWidth, pageHeight, watermarkLogoDataUrl);
    }
  }

  // Show save dialog and save
  try {
    const defaultFileName = `${projectName || 'Untitled'}-cutting-diagrams.pdf`;
    const result = await window.electronAPI.showSaveDialog({
      defaultPath: defaultFileName,
      filters: [{ name: 'PDF Files', extensions: ['pdf'] }]
    });

    if (result.canceled || !result.filePath) {
      return { success: false, canceled: true };
    }

    // Convert PDF to array buffer and save as binary
    const pdfArrayBuffer = doc.output('arraybuffer');
    const uint8Array = new Uint8Array(pdfArrayBuffer);
    const numberArray = Array.from(uint8Array);

    await window.electronAPI.writeBinaryFile(result.filePath, numberArray);

    return { success: true, filePath: result.filePath };
  } catch (error) {
    logger.error('PDF export error:', error);
    return { success: false, error: String(error) };
  }
}

/**
 * Export cut list to CSV with watermark header
 */
export function exportCutListToCsv(cutList: CutList, units: 'imperial' | 'metric'): string {
  const grouped = groupCutInstructions(cutList.instructions);
  const unitLabel = units === 'imperial' ? 'inches' : 'mm';

  const rows = [
    getCsvHeader(),
    'CUT LIST',
    `Units: ${unitLabel}`,
    '',
    ['Qty', 'Cut Length', 'Cut Width', 'Thickness', 'Stock', 'Grain Sensitive', 'Glue-Up', 'Part Names'].join(',')
  ];

  for (const group of grouped) {
    const partNames = group.items.map((i) => i.partName).join('; ');
    rows.push(
      [
        group.quantity.toString(),
        csvEscape(formatMeasurementWithUnit(group.cutLength, units)),
        csvEscape(formatMeasurementWithUnit(group.cutWidth, units)),
        csvEscape(formatMeasurementWithUnit(group.thickness, units)),
        csvEscape(group.stockName),
        group.grainSensitive ? 'Yes' : 'No',
        group.isGlueUp ? 'Yes' : 'No',
        csvEscape(partNames)
      ].join(',')
    );
  }

  return rows.join('\n');
}

/**
 * Export shopping list to CSV with watermark header
 */
export function exportShoppingListToCsv(
  cutList: CutList,
  customShoppingItems: CustomShoppingItem[],
  units: 'imperial' | 'metric'
): string {
  const unitLabel = units === 'imperial' ? 'inches' : 'mm';
  const lines = [
    getCsvHeader(),
    'SHOPPING LIST',
    `Units: ${unitLabel}`,
    '',
    'LUMBER & SHEET GOODS',
    'Stock,Dimensions,Quantity,Unit Price,Total'
  ];

  for (const summary of cutList.statistics.byStock) {
    const dims = `${formatMeasurementWithUnit(summary.stockLength, units)} x ${formatMeasurementWithUnit(summary.stockWidth, units)} x ${formatMeasurementWithUnit(summary.stockThickness, units)}`;
    const unitPrice =
      summary.pricingUnit === 'board_foot'
        ? `$${summary.pricePerUnit.toFixed(2)}/bf`
        : `$${summary.pricePerUnit.toFixed(2)}/ea`;
    lines.push(
      `${csvEscape(summary.stockName)},${csvEscape(dims)},${summary.boardsNeeded},${unitPrice},$${summary.cost.toFixed(2)}`
    );
  }

  lines.push(`Lumber Subtotal,,,,$${cutList.statistics.estimatedCost.toFixed(2)}`);

  if (customShoppingItems.length > 0) {
    lines.push('');
    lines.push('OTHER ITEMS');
    lines.push('Item,Description,Quantity,Unit Price,Total');

    let customTotal = 0;
    for (const item of customShoppingItems) {
      const itemTotal = item.quantity * item.unitPrice;
      customTotal += itemTotal;
      lines.push(
        `${csvEscape(item.name)},${csvEscape(item.description || '')},${item.quantity},$${item.unitPrice.toFixed(2)},$${itemTotal.toFixed(2)}`
      );
    }

    lines.push(`Other Items Subtotal,,,,$${customTotal.toFixed(2)}`);
  }

  const customTotal = customShoppingItems.reduce((sum, item) => sum + item.quantity * item.unitPrice, 0);
  const grandTotal = cutList.statistics.estimatedCost + customTotal;

  lines.push('');
  lines.push(`GRAND TOTAL,,,,$${grandTotal.toFixed(2)}`);

  return lines.join('\n');
}

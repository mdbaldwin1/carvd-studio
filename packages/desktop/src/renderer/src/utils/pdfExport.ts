/**
 * PDF Export utilities for cutting diagrams, cut lists, shopping lists, and project reports
 * Uses jsPDF to programmatically draw diagrams and tables
 */

import jsPDF from 'jspdf';
import { CutList, CutInstruction, StockBoard, CustomShoppingItem } from '../types';
import { formatMeasurementWithUnit } from './fractions';
import { logger } from './logger';

interface ExportOptions {
  projectName: string;
  units: 'imperial' | 'metric';
}

interface ProjectReportOptions extends ExportOptions {
  projectNotes?: string;
  thumbnailData?: string; // Base64 PNG data URL
  customShoppingItems: CustomShoppingItem[];
}

// Grouped cut instruction for parts with identical dimensions
interface GroupedCutInstruction {
  key: string;
  cutLength: number;
  cutWidth: number;
  thickness: number;
  stockId: string;
  stockName: string;
  grainSensitive: boolean;
  isGlueUp: boolean;
  quantity: number;
  items: CutInstruction[];
}

const WATERMARK_TEXT = 'Generated by Carvd Studio - carvd-studio.com';
const WATERMARK_LOGO_LOAD_TIMEOUT_MS = 1200;
const PDF_FONT_SCALE = 1.15;
let watermarkLogoPromise: Promise<string | null> | null = null;

function setPdfFontSize(doc: jsPDF, size: number): void {
  doc.setFontSize(Math.round(size * PDF_FONT_SCALE * 10) / 10);
}

async function loadSvgAsPngDataUrl(path: string, targetHeight: number): Promise<string | null> {
  try {
    const img = new window.Image();
    img.decoding = 'async';
    await new Promise<void>((resolve, reject) => {
      const timeoutId = window.setTimeout(() => {
        cleanup();
        reject(new Error(`Timed out loading image: ${path}`));
      }, WATERMARK_LOGO_LOAD_TIMEOUT_MS);

      const cleanup = () => {
        window.clearTimeout(timeoutId);
        img.onload = null;
        img.onerror = null;
      };

      img.onload = () => {
        cleanup();
        resolve();
      };
      img.onerror = () => {
        cleanup();
        reject(new Error(`Failed to load image: ${path}`));
      };
      img.src = path;
    });

    if (img.width <= 0 || img.height <= 0) {
      return null;
    }

    const scale = targetHeight / img.height;
    const width = Math.max(1, Math.round(img.width * scale));
    const height = Math.max(1, Math.round(targetHeight));

    // Render at higher internal resolution so the image remains sharp in PDFs.
    const renderScale = Math.max(4, Math.ceil((window.devicePixelRatio || 1) * 3));

    const canvas = document.createElement('canvas');
    canvas.width = width * renderScale;
    canvas.height = height * renderScale;

    const ctx = canvas.getContext('2d');
    if (!ctx) return null;
    ctx.scale(renderScale, renderScale);
    ctx.drawImage(img, 0, 0, width, height);

    return canvas.toDataURL('image/png');
  } catch {
    return null;
  }
}

async function getWatermarkLogoDataUrl(): Promise<string | null> {
  if (!watermarkLogoPromise) {
    // Horizontal lockup renders best as a compact footer watermark on white PDF pages.
    watermarkLogoPromise = loadSvgAsPngDataUrl('/branding/CarvdStudio-Horizontal.svg', 20);
  }
  return watermarkLogoPromise;
}

/**
 * Add watermark to bottom of page
 */
function addWatermark(doc: jsPDF, pageWidth: number, pageHeight: number, logoDataUrl?: string | null): void {
  const baselineY = pageHeight - 15;
  setPdfFontSize(doc, 8);
  doc.setTextColor(150, 150, 150);

  if (!logoDataUrl) {
    doc.text(WATERMARK_TEXT, pageWidth / 2, baselineY, { align: 'center' });
    return;
  }

  const logoHeight = 12;
  let logoWidth = 72;
  try {
    const imageProps = doc.getImageProperties(logoDataUrl);
    if (imageProps.width > 0 && imageProps.height > 0) {
      logoWidth = (logoHeight * imageProps.width) / imageProps.height;
    }
  } catch {
    // Fallback to default dimensions if image metadata isn't available.
  }
  const gap = 7;
  const textWidth = doc.getTextWidth(WATERMARK_TEXT);
  const totalWidth = logoWidth + gap + textWidth;
  const startX = (pageWidth - totalWidth) / 2;

  doc.addImage(logoDataUrl, 'PNG', startX, baselineY - logoHeight + 2, logoWidth, logoHeight);
  doc.text(WATERMARK_TEXT, startX + logoWidth + gap, baselineY);
}

function drawBoardDiagram(
  doc: jsPDF,
  board: StockBoard,
  stockName: string,
  units: 'imperial' | 'metric',
  area: { x: number; y: number; width: number; height: number },
  options?: { rotateBoard?: boolean; title?: string }
): void {
  const rotateBoard = options?.rotateBoard === true;
  const title = options?.title ?? `${stockName} - Board #${board.boardIndex}`;
  const headerHeight = 34;
  setPdfFontSize(doc, 12);
  doc.setFont('helvetica', 'bold');
  doc.setTextColor(0, 0, 0);
  doc.text(title, area.x, area.y + 14);

  setPdfFontSize(doc, 9);
  doc.setFont('helvetica', 'normal');
  const dims = `${formatMeasurementWithUnit(board.stockLength, units)} × ${formatMeasurementWithUnit(board.stockWidth, units)}`;
  doc.text(dims, area.x, area.y + 30);
  doc.text(
    `${board.placements.length} part${board.placements.length !== 1 ? 's' : ''} | ${board.utilizationPercent.toFixed(1)}% utilization`,
    area.x + area.width - 150,
    area.y + 14
  );

  const legendRowHeight = 13;
  const legendHeaderHeight = 16;
  const legendMaxRows = 10;
  const legendRows = Math.min(legendMaxRows, board.placements.length);
  const legendHeight = legendHeaderHeight + legendRows * legendRowHeight + 8;
  const legendGap = 10;

  const diagramTop = area.y + headerHeight;
  const diagramAreaHeight = Math.max(40, area.height - headerHeight - legendHeight - legendGap);
  const diagramAreaWidth = area.width;
  const renderBoardLength = rotateBoard ? board.stockWidth : board.stockLength;
  const renderBoardWidth = rotateBoard ? board.stockLength : board.stockWidth;
  const scaleX = diagramAreaWidth / renderBoardLength;
  const scaleY = diagramAreaHeight / renderBoardWidth;
  const scale = Math.min(scaleX, scaleY);

  const diagramWidth = renderBoardLength * scale;
  const diagramHeight = renderBoardWidth * scale;
  const diagramX = area.x + (diagramAreaWidth - diagramWidth) / 2;
  const diagramY = diagramTop + (diagramAreaHeight - diagramHeight) / 2;

  doc.setDrawColor(60, 60, 60);
  doc.setLineWidth(2);
  doc.setFillColor(245, 240, 230);
  doc.rect(diagramX, diagramY, diagramWidth, diagramHeight, 'FD');

  const sortedPlacements = [...board.placements].sort((a, b) => {
    if (Math.abs(a.y - b.y) > 0.001) return a.y - b.y;
    return a.x - b.x;
  });
  const numberByPartId = new Map(sortedPlacements.map((p, idx) => [p.partId, idx + 1]));

  const externalCallouts: Array<{
    anchorX: number;
    anchorY: number;
    partX: number;
    partY: number;
    partW: number;
    partH: number;
    side: 'left' | 'right';
    text: string;
  }> = [];

  for (const placement of sortedPlacements) {
    let px = placement.x;
    let py = placement.y;
    let pw = placement.width;
    let ph = placement.height;

    if (rotateBoard) {
      px = placement.y;
      py = board.stockLength - placement.x - placement.width;
      pw = placement.height;
      ph = placement.width;
    }

    const x = diagramX + px * scale;
    const y = diagramY + py * scale;
    const w = pw * scale;
    const h = ph * scale;

    doc.setFillColor(210, 185, 135);
    doc.setDrawColor(100, 70, 40);
    doc.setLineWidth(1);
    doc.rect(x, y, w, h, 'FD');

    const partNumber = numberByPartId.get(placement.partId) ?? 0;
    const partNumberLabel = String(partNumber);
    const maxFontSize = 13;
    const minFontSize = 8;
    const fontSizeByWidth = w / 3;
    const fontSizeByHeight = h / 2.4;
    const fontSize = Math.max(minFontSize, Math.min(maxFontSize, fontSizeByWidth, fontSizeByHeight));

    setPdfFontSize(doc, fontSize);
    doc.setFont('helvetica', 'bold');
    doc.setTextColor(25, 18, 10);

    if (w > 18 && h > 12) {
      const textWidth = doc.getTextWidth(partNumberLabel);
      const textX = x + (w - textWidth) / 2;
      const textY = y + h / 2 + fontSize * 0.35;
      doc.text(partNumberLabel, textX, textY);
    } else {
      const side: 'left' | 'right' = x + w / 2 >= diagramX + diagramWidth / 2 ? 'right' : 'left';
      externalCallouts.push({
        anchorX: x + w / 2,
        anchorY: y + h / 2,
        partX: x,
        partY: y,
        partW: w,
        partH: h,
        side,
        text: partNumberLabel
      });
    }
  }

  const drawCalloutSide = (side: 'left' | 'right') => {
    const sideCallouts = externalCallouts.filter((c) => c.side === side).sort((a, b) => a.anchorY - b.anchorY);
    if (sideCallouts.length === 0) return;

    const top = diagramY + 8;
    const bottom = diagramY + diagramHeight - 8;
    const labelX = side === 'right' ? diagramX + diagramWidth + 22 : diagramX - 22;
    const minLaneGap = 8;

    let targetYs: number[] = sideCallouts.map((callout) => Math.min(bottom, Math.max(top, callout.anchorY)));
    const availableHeight = bottom - top;
    const maxFittableGap = sideCallouts.length > 1 ? availableHeight / (sideCallouts.length - 1) : availableHeight;
    const effectiveGap = Math.min(minLaneGap, maxFittableGap);

    if (sideCallouts.length > 1 && effectiveGap > 0) {
      // Forward pass: enforce minimum gap while preserving order.
      for (let i = 1; i < targetYs.length; i++) {
        targetYs[i] = Math.max(targetYs[i], targetYs[i - 1] + effectiveGap);
      }

      // Backward pass: pull lanes back into bounds.
      const overflow = targetYs[targetYs.length - 1] - bottom;
      if (overflow > 0) {
        for (let i = 0; i < targetYs.length; i++) {
          targetYs[i] -= overflow;
        }
      }
      for (let i = targetYs.length - 2; i >= 0; i--) {
        targetYs[i] = Math.min(targetYs[i], targetYs[i + 1] - effectiveGap);
      }
    }

    targetYs = targetYs.map((y) => Math.min(bottom, Math.max(top, y)));

    doc.setDrawColor(80, 80, 80);
    doc.setLineWidth(0.8);
    doc.setFont('helvetica', 'bold');
    setPdfFontSize(doc, 7);
    doc.setTextColor(35, 35, 35);

    let nearbyAnchorCluster = 0;
    sideCallouts.forEach((callout, index) => {
      const prev = index > 0 ? sideCallouts[index - 1] : null;
      nearbyAnchorCluster = prev && Math.abs(callout.anchorY - prev.anchorY) < 7 ? nearbyAnchorCluster + 1 : 0;
      const elbowOffset = 10 + Math.min(nearbyAnchorCluster, 3) * 4;
      const targetY = targetYs[index];
      // Prefer anchoring directly on the label lane so leaders are straight
      // horizontal whenever the part bounds allow it.
      const adjustedAnchorY = Math.min(callout.partY + callout.partH - 0.6, Math.max(callout.partY + 0.6, targetY));
      const adjustedAnchorX =
        side === 'right'
          ? Math.min(callout.partX + callout.partW - 0.6, callout.partX + callout.partW * 0.7)
          : Math.max(callout.partX + 0.6, callout.partX + callout.partW * 0.3);
      const elbowX = side === 'right' ? adjustedAnchorX + elbowOffset : adjustedAnchorX - elbowOffset;
      const textX = side === 'right' ? labelX + 2 : labelX - 2;

      if (typeof (doc as unknown as { line?: (...args: number[]) => void }).line === 'function') {
        // Route with orthogonal segments (stub -> vertical lane -> label)
        // to reduce ambiguous overlap for neighboring small-part callouts.
        doc.line(adjustedAnchorX, adjustedAnchorY, elbowX, adjustedAnchorY);
        doc.line(elbowX, adjustedAnchorY, elbowX, targetY);
        doc.line(elbowX, targetY, labelX, targetY);
      }

      // Small anchor point
      if (typeof (doc as unknown as { circle?: (...args: unknown[]) => void }).circle === 'function') {
        doc.setFillColor(80, 80, 80);
        doc.circle(adjustedAnchorX, adjustedAnchorY, 0.9, 'F');
      }

      if (side === 'right') {
        doc.text(callout.text, textX, targetY + 2, { align: 'left' });
      } else {
        doc.text(callout.text, textX, targetY + 2, { align: 'right' });
      }
    });
  };

  drawCalloutSide('left');
  drawCalloutSide('right');

  // Legend / checklist table
  const legendY = diagramY + diagramHeight + legendGap;
  const colCheck = area.x + 4;
  const colNum = area.x + 18;
  const colName = area.x + 44;
  const colDims = area.x + area.width - 140;

  doc.setFillColor(240, 240, 240);
  doc.rect(area.x, legendY, area.width, legendHeaderHeight, 'F');
  doc.setFont('helvetica', 'bold');
  setPdfFontSize(doc, 8);
  doc.setTextColor(0, 0, 0);
  doc.text('\u2610', colCheck, legendY + 11);
  doc.text('#', colNum, legendY + 11);
  doc.text('Part', colName, legendY + 11);
  doc.text('Dimensions', colDims, legendY + 11);

  doc.setFont('helvetica', 'normal');
  setPdfFontSize(doc, 8);
  for (let i = 0; i < legendRows; i++) {
    const placement = sortedPlacements[i];
    const rowY = legendY + legendHeaderHeight + i * legendRowHeight + 10;
    const partNumber = numberByPartId.get(placement.partId) ?? i + 1;
    const dims = `${formatMeasurementWithUnit(placement.width, units)} × ${formatMeasurementWithUnit(placement.height, units)}`;

    drawChecklistBox(doc, colCheck, rowY, 7);
    doc.text(String(partNumber), colNum, rowY);

    let displayName = placement.partName;
    const maxNameWidth = colDims - colName - 8;
    while (doc.getTextWidth(displayName) > maxNameWidth && displayName.length > 10) {
      displayName = `${displayName.slice(0, -4)}...`;
    }
    doc.text(displayName, colName, rowY);
    doc.text(dims, colDims, rowY);
  }

  if (sortedPlacements.length > legendRows) {
    doc.setFont('helvetica', 'italic');
    setPdfFontSize(doc, 7);
    doc.setTextColor(90, 90, 90);
    doc.text(
      `+ ${sortedPlacements.length - legendRows} more parts`,
      colName,
      legendY + legendHeaderHeight + legendRows * legendRowHeight + 8
    );
  }
}

function getBestDiagramLayout(
  board: StockBoard,
  margin: number,
  headerHeight: number,
  footerReserve: number
): { pageOrientation: 'portrait' | 'landscape'; rotateBoard: boolean } {
  const layouts: Array<{
    pageOrientation: 'portrait' | 'landscape';
    rotateBoard: boolean;
    scale: number;
    diagramWidth: number;
    diagramHeight: number;
  }> = [];
  const pagePresets: Array<{ pageOrientation: 'portrait' | 'landscape'; width: number; height: number }> = [
    { pageOrientation: 'portrait', width: 612, height: 792 },
    { pageOrientation: 'landscape', width: 792, height: 612 }
  ];

  for (const preset of pagePresets) {
    const usableWidth = preset.width - margin * 2;
    const usableHeight = preset.height - margin * 2 - headerHeight - footerReserve;

    const normalScale = Math.min(usableWidth / board.stockLength, usableHeight / board.stockWidth);
    layouts.push({
      pageOrientation: preset.pageOrientation,
      rotateBoard: false,
      scale: normalScale,
      diagramWidth: board.stockLength * normalScale,
      diagramHeight: board.stockWidth * normalScale
    });

    const rotatedScale = Math.min(usableWidth / board.stockWidth, usableHeight / board.stockLength);
    layouts.push({
      pageOrientation: preset.pageOrientation,
      rotateBoard: true,
      scale: rotatedScale,
      diagramWidth: board.stockWidth * rotatedScale,
      diagramHeight: board.stockLength * rotatedScale
    });
  }

  layouts.sort((a, b) => b.scale - a.scale);
  const best = layouts[0];

  // Woodworker readability preference:
  // for long boards, prefer a vertical rendering if it is close in size.
  const longBoardRatio =
    Math.max(board.stockLength, board.stockWidth) / Math.max(1, Math.min(board.stockLength, board.stockWidth));
  if (longBoardRatio >= 2) {
    const bestVertical = layouts.filter((l) => l.diagramHeight > l.diagramWidth).sort((a, b) => b.scale - a.scale)[0];

    if (bestVertical && bestVertical.scale >= best.scale * 0.92) {
      return { pageOrientation: bestVertical.pageOrientation, rotateBoard: bestVertical.rotateBoard };
    }
  }

  return { pageOrientation: best.pageOrientation, rotateBoard: best.rotateBoard };
}

function buildBoardLabel(board: StockBoard): string {
  const stockToken =
    board.stockName
      .replace(/[^A-Za-z0-9]+/g, '')
      .slice(0, 4)
      .toUpperCase() || 'STK';
  return `${stockToken}-${String(board.boardIndex).padStart(2, '0')}`;
}

function buildPartBoardMap(stockBoards: StockBoard[]): Map<string, Set<string>> {
  const map = new Map<string, Set<string>>();
  for (const board of stockBoards) {
    const boardLabel = buildBoardLabel(board);
    for (const placement of board.placements) {
      const existing = map.get(placement.partId) ?? new Set<string>();
      existing.add(boardLabel);
      map.set(placement.partId, existing);
    }
  }
  return map;
}

function drawChecklistBox(doc: jsPDF, x: number, y: number, size = 8): void {
  doc.setDrawColor(80, 80, 80);
  doc.setLineWidth(0.8);
  doc.rect(x, y - size + 1, size, size);
}

function getShortPartId(partId: string): string {
  return partId.length <= 8 ? partId : partId.slice(0, 8);
}

/**
 * Group identical cut instructions together
 */
function groupCutInstructions(instructions: CutInstruction[]): GroupedCutInstruction[] {
  const groups = new Map<string, GroupedCutInstruction>();

  for (const inst of instructions) {
    const key = `${inst.cutLength}-${inst.cutWidth}-${inst.thickness}-${inst.stockId}-${inst.grainSensitive}-${inst.isGlueUp}`;

    const existing = groups.get(key);
    if (existing) {
      existing.quantity++;
      existing.items.push(inst);
    } else {
      groups.set(key, {
        key,
        cutLength: inst.cutLength,
        cutWidth: inst.cutWidth,
        thickness: inst.thickness,
        stockId: inst.stockId,
        stockName: inst.stockName,
        grainSensitive: inst.grainSensitive,
        isGlueUp: inst.isGlueUp,
        quantity: 1,
        items: [inst]
      });
    }
  }

  return Array.from(groups.values());
}

/**
 * Helper to escape CSV values (double quotes become doubled)
 */
function csvEscape(value: string): string {
  return `"${value.replace(/"/g, '""')}"`;
}

/**
 * Generate CSV header comment with watermark
 */
export function getCsvHeader(): string {
  return `# Generated by Carvd Studio\n# https://carvd-studio.com\n# Date: ${new Date().toLocaleString()}\n\n`;
}

/**
 * Export cut list to PDF
 */
export async function exportCutListToPdf(
  cutList: CutList,
  options: ExportOptions
): Promise<{ success: boolean; filePath?: string; error?: string; canceled?: boolean }> {
  const { projectName, units } = options;
  const partBoardMap = buildPartBoardMap(cutList.stockBoards);

  const doc = new jsPDF({
    orientation: 'portrait',
    unit: 'pt',
    format: 'letter'
  });

  const pageWidth = doc.internal.pageSize.getWidth();
  const pageHeight = doc.internal.pageSize.getHeight();
  const margin = 40;
  const contentWidth = pageWidth - margin * 2;
  const watermarkLogoDataUrl = await getWatermarkLogoDataUrl();

  // Title
  setPdfFontSize(doc, 20);
  doc.setFont('helvetica', 'bold');
  doc.setTextColor(0, 0, 0);
  doc.text(projectName || 'Cut List', margin, margin + 25);

  setPdfFontSize(doc, 10);
  doc.setFont('helvetica', 'normal');
  doc.text(`Generated: ${new Date().toLocaleDateString()}`, margin, margin + 42);
  doc.text(`${cutList.instructions.length} parts, ${cutList.stockBoards.length} boards needed`, margin, margin + 55);

  // Group instructions
  const grouped = groupCutInstructions(cutList.instructions);

  // Table header
  let y = margin + 80;
  const colWidths = [12, 28, 148, 58, 58, 48, 86, 78];
  const colX = [
    margin + 2,
    margin + 18,
    margin + 48,
    margin + 196,
    margin + 254,
    margin + 312,
    margin + 360,
    margin + 446
  ];

  doc.setFillColor(240, 240, 240);
  doc.rect(margin, y - 12, contentWidth, 18, 'F');
  setPdfFontSize(doc, 9);
  doc.setFont('helvetica', 'bold');
  doc.text('\u2610', colX[0], y);
  doc.text('Qty', colX[1], y);
  doc.text('Part IDs + Names', colX[2], y);
  doc.text('Length', colX[3], y);
  doc.text('Width', colX[4], y);
  doc.text('Thk', colX[5], y);
  doc.text('Stock', colX[6], y);
  doc.text('Boards', colX[7], y);

  y += 18;
  doc.setFont('helvetica', 'normal');
  setPdfFontSize(doc, 9);

  for (const group of grouped) {
    // Check for page break
    if (y > pageHeight - 60) {
      addWatermark(doc, pageWidth, pageHeight, watermarkLogoDataUrl);
      doc.addPage();
      y = margin + 20;
    }

    // Part names and IDs (join if multiple)
    const partNames = group.items.map((i) => i.partName).join(', ');
    const partIds = group.items.map((i) => `#${getShortPartId(i.partId)}`).join(', ');
    const partBoards = Array.from(
      new Set(group.items.flatMap((i) => Array.from(partBoardMap.get(i.partId) ?? [])))
    ).join(', ');
    const notes: string[] = [];
    if (group.grainSensitive) notes.push('Grain');
    if (group.isGlueUp) notes.push('Glue-up');

    drawChecklistBox(doc, colX[0], y, 7);
    doc.text(group.quantity.toString(), colX[1], y);

    // Truncate part labels if too long
    const maxNameWidth = colWidths[2] - 5;
    let displayName = `${partIds} ${partNames}`;
    while (doc.getTextWidth(displayName) > maxNameWidth && displayName.length > 10) {
      displayName = displayName.substring(0, displayName.length - 4) + '...';
    }
    doc.text(displayName, colX[2], y);

    doc.text(formatMeasurementWithUnit(group.cutLength, units), colX[3], y);
    doc.text(formatMeasurementWithUnit(group.cutWidth, units), colX[4], y);
    doc.text(formatMeasurementWithUnit(group.thickness, units), colX[5], y);

    // Stock name with notes
    const stockWithNotes = notes.length > 0 ? `${group.stockName} (${notes.join(', ')})` : group.stockName;
    let displayStock = stockWithNotes;
    while (doc.getTextWidth(displayStock) > colWidths[6] - 4 && displayStock.length > 10) {
      displayStock = displayStock.substring(0, displayStock.length - 4) + '...';
    }
    doc.text(displayStock, colX[6], y);

    let displayBoards = partBoards || '-';
    while (doc.getTextWidth(displayBoards) > colWidths[7] - 4 && displayBoards.length > 6) {
      displayBoards = displayBoards.substring(0, displayBoards.length - 4) + '...';
    }
    doc.text(displayBoards, colX[7], y);

    y += 16;
  }

  addWatermark(doc, pageWidth, pageHeight, watermarkLogoDataUrl);

  // Save
  try {
    const defaultFileName = `${projectName || 'cut-list'}-parts.pdf`;
    const result = await window.electronAPI.showSaveDialog({
      defaultPath: defaultFileName,
      filters: [{ name: 'PDF Files', extensions: ['pdf'] }]
    });

    if (result.canceled || !result.filePath) {
      return { success: false, canceled: true };
    }

    const pdfArrayBuffer = doc.output('arraybuffer');
    const uint8Array = new Uint8Array(pdfArrayBuffer);
    const numberArray = Array.from(uint8Array);

    await window.electronAPI.writeBinaryFile(result.filePath, numberArray);

    return { success: true, filePath: result.filePath };
  } catch (error) {
    logger.error('Cut list PDF export error:', error);
    return { success: false, error: String(error) };
  }
}

/**
 * Export shopping list to PDF
 */
export async function exportShoppingListToPdf(
  cutList: CutList,
  customShoppingItems: CustomShoppingItem[],
  options: ExportOptions
): Promise<{ success: boolean; filePath?: string; error?: string; canceled?: boolean }> {
  const { projectName, units } = options;

  const doc = new jsPDF({
    orientation: 'portrait',
    unit: 'pt',
    format: 'letter'
  });

  const pageWidth = doc.internal.pageSize.getWidth();
  const pageHeight = doc.internal.pageSize.getHeight();
  const margin = 40;
  const contentWidth = pageWidth - margin * 2;
  const watermarkLogoDataUrl = await getWatermarkLogoDataUrl();

  // Title
  setPdfFontSize(doc, 20);
  doc.setFont('helvetica', 'bold');
  doc.setTextColor(0, 0, 0);
  doc.text(`${projectName || 'Project'} - Shopping List`, margin, margin + 25);

  setPdfFontSize(doc, 10);
  doc.setFont('helvetica', 'normal');
  doc.text(`Generated: ${new Date().toLocaleDateString()}`, margin, margin + 42);

  let y = margin + 70;

  // Lumber & Sheet Goods Section
  setPdfFontSize(doc, 14);
  doc.setFont('helvetica', 'bold');
  doc.text('Lumber & Sheet Goods', margin, y);
  y += 25;

  // Table header
  doc.setFillColor(240, 240, 240);
  doc.rect(margin, y - 12, contentWidth, 18, 'F');
  setPdfFontSize(doc, 9);
  doc.text('\u2610', margin + 5, y);
  doc.text('Stock', margin + 22, y);
  doc.text('Dimensions', margin + 176, y);
  doc.text('Qty', margin + 332, y);
  doc.text('Unit Price', margin + 378, y);
  doc.text('Total', margin + 456, y);
  y += 18;

  doc.setFont('helvetica', 'normal');

  for (const summary of cutList.statistics.byStock) {
    if (y > pageHeight - 80) {
      addWatermark(doc, pageWidth, pageHeight, watermarkLogoDataUrl);
      doc.addPage();
      y = margin + 20;
    }

    const dims = `${formatMeasurementWithUnit(summary.stockLength, units)} x ${formatMeasurementWithUnit(summary.stockWidth, units)} x ${formatMeasurementWithUnit(summary.stockThickness, units)}`;
    const unitPrice =
      summary.pricingUnit === 'board_foot'
        ? `$${summary.pricePerUnit.toFixed(2)}/bf`
        : `$${summary.pricePerUnit.toFixed(2)}/ea`;

    drawChecklistBox(doc, margin + 5, y, 7);
    doc.text(summary.stockName, margin + 22, y);
    doc.text(dims, margin + 176, y);
    doc.text(summary.boardsNeeded.toString(), margin + 332, y);
    doc.text(unitPrice, margin + 378, y);
    doc.text(`$${summary.cost.toFixed(2)}`, margin + 456, y);
    y += 16;
  }

  // Lumber subtotal
  y += 5;
  doc.setFont('helvetica', 'bold');
  doc.text('Lumber Subtotal:', margin + 350, y);
  doc.text(`$${cutList.statistics.estimatedCost.toFixed(2)}`, margin + 450, y);
  y += 25;

  // Custom items section
  if (customShoppingItems.length > 0) {
    setPdfFontSize(doc, 14);
    doc.text('Other Items', margin, y);
    y += 25;

    // Table header
    doc.setFillColor(240, 240, 240);
    doc.rect(margin, y - 12, contentWidth, 18, 'F');
    setPdfFontSize(doc, 9);
    doc.text('\u2610', margin + 5, y);
    doc.text('Item', margin + 22, y);
    doc.text('Description', margin + 190, y);
    doc.text('Qty', margin + 332, y);
    doc.text('Unit Price', margin + 378, y);
    doc.text('Total', margin + 456, y);
    y += 18;

    doc.setFont('helvetica', 'normal');

    let customTotal = 0;
    for (const item of customShoppingItems) {
      if (y > pageHeight - 80) {
        addWatermark(doc, pageWidth, pageHeight, watermarkLogoDataUrl);
        doc.addPage();
        y = margin + 20;
      }

      const itemTotal = item.quantity * item.unitPrice;
      customTotal += itemTotal;

      drawChecklistBox(doc, margin + 5, y, 7);
      doc.text(item.name, margin + 22, y);
      doc.text(item.description || '', margin + 190, y);
      doc.text(item.quantity.toString(), margin + 332, y);
      doc.text(`$${item.unitPrice.toFixed(2)}`, margin + 378, y);
      doc.text(`$${itemTotal.toFixed(2)}`, margin + 456, y);
      y += 16;
    }

    // Custom items subtotal
    y += 5;
    doc.setFont('helvetica', 'bold');
    doc.text('Other Items Subtotal:', margin + 330, y);
    doc.text(`$${customTotal.toFixed(2)}`, margin + 450, y);
    y += 25;
  }

  // Grand total
  const customTotal = customShoppingItems.reduce((sum, item) => sum + item.quantity * item.unitPrice, 0);
  const grandTotal = cutList.statistics.estimatedCost + customTotal;

  setPdfFontSize(doc, 12);
  doc.setFont('helvetica', 'bold');
  doc.setFillColor(230, 230, 230);
  doc.rect(margin + 300, y - 12, contentWidth - 300, 22, 'F');
  doc.text('GRAND TOTAL:', margin + 330, y + 2);
  doc.text(`$${grandTotal.toFixed(2)}`, margin + 450, y + 2);

  addWatermark(doc, pageWidth, pageHeight, watermarkLogoDataUrl);

  // Save
  try {
    const defaultFileName = `${projectName || 'Untitled'}-shopping-list.pdf`;
    const result = await window.electronAPI.showSaveDialog({
      defaultPath: defaultFileName,
      filters: [{ name: 'PDF Files', extensions: ['pdf'] }]
    });

    if (result.canceled || !result.filePath) {
      return { success: false, canceled: true };
    }

    const pdfArrayBuffer = doc.output('arraybuffer');
    const uint8Array = new Uint8Array(pdfArrayBuffer);
    const numberArray = Array.from(uint8Array);

    await window.electronAPI.writeBinaryFile(result.filePath, numberArray);

    return { success: true, filePath: result.filePath };
  } catch (error) {
    logger.error('Shopping list PDF export error:', error);
    return { success: false, error: String(error) };
  }
}

/**
 * Export comprehensive project report to PDF
 * Includes: cover page with thumbnail, cut list, cutting diagrams, shopping list
 */
export async function exportProjectReportToPdf(
  cutList: CutList,
  options: ProjectReportOptions
): Promise<{ success: boolean; filePath?: string; error?: string; canceled?: boolean }> {
  const { projectName, projectNotes, thumbnailData, units, customShoppingItems } = options;
  const partBoardMap = buildPartBoardMap(cutList.stockBoards);

  const doc = new jsPDF({
    orientation: 'portrait',
    unit: 'pt',
    format: 'letter'
  });

  const pageWidth = doc.internal.pageSize.getWidth();
  const pageHeight = doc.internal.pageSize.getHeight();
  const margin = 40;
  const contentWidth = pageWidth - margin * 2;
  const watermarkLogoDataUrl = await getWatermarkLogoDataUrl();

  // ============ COVER PAGE ============
  let y = margin + 40;

  // Project thumbnail (if available)
  if (thumbnailData) {
    try {
      const imgWidth = 400;
      const imgHeight = 250;
      const imgX = (pageWidth - imgWidth) / 2;
      doc.addImage(thumbnailData, 'PNG', imgX, y, imgWidth, imgHeight);
      y += imgHeight + 30;
    } catch (e) {
      logger.warn('Failed to add thumbnail to PDF:', e);
      y += 20;
    }
  }

  // Project title
  setPdfFontSize(doc, 28);
  doc.setFont('helvetica', 'bold');
  doc.setTextColor(0, 0, 0);
  doc.text(projectName || 'Project Report', pageWidth / 2, y, { align: 'center' });
  y += 35;

  // Subtitle
  setPdfFontSize(doc, 12);
  doc.setFont('helvetica', 'normal');
  doc.setTextColor(100, 100, 100);
  doc.text('Cut List & Material Report', pageWidth / 2, y, { align: 'center' });
  y += 25;

  setPdfFontSize(doc, 10);
  doc.text(`Generated: ${new Date().toLocaleDateString()}`, pageWidth / 2, y, { align: 'center' });
  y += 40;

  // Project notes/description
  if (projectNotes) {
    setPdfFontSize(doc, 11);
    doc.setTextColor(60, 60, 60);
    doc.setFont('helvetica', 'italic');

    const splitNotes = doc.splitTextToSize(projectNotes, contentWidth - 40);
    doc.text(splitNotes, margin + 20, y);
    y += splitNotes.length * 14 + 20;
  }

  // Quick stats box
  y = Math.max(y, pageHeight - 200);
  doc.setFillColor(245, 245, 245);
  doc.roundedRect(margin, y, contentWidth, 100, 8, 8, 'F');

  setPdfFontSize(doc, 10);
  doc.setFont('helvetica', 'bold');
  doc.setTextColor(0, 0, 0);

  const statsY = y + 25;
  const col1 = margin + 30;
  const col2 = margin + 150;
  const col3 = margin + 300;
  const col4 = margin + 430;

  doc.text('Parts:', col1, statsY);
  doc.text('Boards:', col2, statsY);
  doc.text('Board Feet:', col3, statsY);
  doc.text('Est. Cost:', col4, statsY);

  doc.setFont('helvetica', 'normal');
  setPdfFontSize(doc, 14);
  doc.text(cutList.statistics.totalParts.toString(), col1, statsY + 20);
  doc.text(cutList.statistics.totalStockBoards.toString(), col2, statsY + 20);
  doc.text(cutList.statistics.totalBoardFeet.toFixed(2), col3, statsY + 20);

  const customTotal = customShoppingItems.reduce((sum, item) => sum + item.quantity * item.unitPrice, 0);
  const grandTotal = cutList.statistics.estimatedCost + customTotal;
  doc.text(`$${grandTotal.toFixed(2)}`, col4, statsY + 20);

  setPdfFontSize(doc, 9);
  doc.setTextColor(100, 100, 100);
  doc.text(`${cutList.statistics.wastePercentage.toFixed(1)}% waste`, col3, statsY + 38);

  addWatermark(doc, pageWidth, pageHeight, watermarkLogoDataUrl);

  // ============ CUT LIST PAGE ============
  doc.addPage();
  y = margin + 20;

  setPdfFontSize(doc, 18);
  doc.setFont('helvetica', 'bold');
  doc.setTextColor(0, 0, 0);
  doc.text('Cut List', margin, y);
  y += 30;

  // Group instructions
  const grouped = groupCutInstructions(cutList.instructions);

  // Table header
  const colWidths2 = [12, 24, 135, 62, 62, 52, 86, 70];
  const colX2 = [
    margin + 2,
    margin + 16,
    margin + 44,
    margin + 180,
    margin + 242,
    margin + 304,
    margin + 360,
    margin + 448
  ];

  doc.setFillColor(240, 240, 240);
  doc.rect(margin, y - 12, contentWidth, 18, 'F');
  setPdfFontSize(doc, 9);
  doc.setFont('helvetica', 'bold');
  doc.text('\u2610', colX2[0], y);
  doc.text('Qty', colX2[1], y);
  doc.text('Part IDs + Names', colX2[2], y);
  doc.text('Length', colX2[3], y);
  doc.text('Width', colX2[4], y);
  doc.text('Thk', colX2[5], y);
  doc.text('Stock', colX2[6], y);
  doc.text('Boards', colX2[7], y);

  y += 18;
  doc.setFont('helvetica', 'normal');
  setPdfFontSize(doc, 8);

  for (const group of grouped) {
    if (y > pageHeight - 50) {
      addWatermark(doc, pageWidth, pageHeight, watermarkLogoDataUrl);
      doc.addPage();
      y = margin + 20;
    }

    const partNames = group.items.map((i) => i.partName).join(', ');
    const partIds = group.items.map((i) => `#${getShortPartId(i.partId)}`).join(', ');
    const partBoards = Array.from(
      new Set(group.items.flatMap((i) => Array.from(partBoardMap.get(i.partId) ?? [])))
    ).join(', ');
    const notes: string[] = [];
    if (group.grainSensitive) notes.push('Grain');
    if (group.isGlueUp) notes.push('Glue-up');

    drawChecklistBox(doc, colX2[0], y, 6);
    doc.text(group.quantity.toString(), colX2[1], y);

    let displayName = `${partIds} ${partNames}`;
    while (doc.getTextWidth(displayName) > colWidths2[2] - 5 && displayName.length > 10) {
      displayName = displayName.substring(0, displayName.length - 4) + '...';
    }
    doc.text(displayName, colX2[2], y);
    doc.text(formatMeasurementWithUnit(group.cutLength, units), colX2[3], y);
    doc.text(formatMeasurementWithUnit(group.cutWidth, units), colX2[4], y);
    doc.text(formatMeasurementWithUnit(group.thickness, units), colX2[5], y);

    const stockWithNotes = notes.length > 0 ? `${group.stockName} (${notes.join(', ')})` : group.stockName;
    let displayStock = stockWithNotes;
    while (doc.getTextWidth(displayStock) > colWidths2[6] - 5 && displayStock.length > 10) {
      displayStock = displayStock.substring(0, displayStock.length - 4) + '...';
    }
    doc.text(displayStock, colX2[6], y);

    let displayBoards = partBoards || '-';
    while (doc.getTextWidth(displayBoards) > colWidths2[7] - 4 && displayBoards.length > 6) {
      displayBoards = displayBoards.substring(0, displayBoards.length - 4) + '...';
    }
    doc.text(displayBoards, colX2[7], y);

    y += 14;
  }

  addWatermark(doc, pageWidth, pageHeight, watermarkLogoDataUrl);

  // ============ CUTTING DIAGRAMS PAGES ============
  // Group boards by stock
  const boardsByStock = new Map<string, StockBoard[]>();
  for (const board of cutList.stockBoards) {
    const existing = boardsByStock.get(board.stockId) || [];
    existing.push(board);
    boardsByStock.set(board.stockId, existing);
  }

  // Draw boards (one board per page, orientation optimized for print readability)
  const diagramMargin = 40;
  const diagramHeaderHeight = 22;
  const diagramFooterReserve = 20;
  for (const [, boards] of boardsByStock) {
    for (const board of boards) {
      const layout = getBestDiagramLayout(board, diagramMargin, diagramHeaderHeight, diagramFooterReserve);
      doc.addPage(layout.pageOrientation);

      const dpageWidth = doc.internal.pageSize.getWidth();
      const dpageHeight = doc.internal.pageSize.getHeight();
      const dcontentWidth = dpageWidth - diagramMargin * 2;
      const dcontentHeight = dpageHeight - diagramMargin * 2 - diagramFooterReserve;

      drawBoardDiagram(
        doc,
        board,
        board.stockName,
        units,
        {
          x: diagramMargin,
          y: diagramMargin,
          width: dcontentWidth,
          height: dcontentHeight
        },
        {
          rotateBoard: layout.rotateBoard,
          title: `Cutting Diagram ${buildBoardLabel(board)} - ${board.stockName} (Board #${board.boardIndex})`
        }
      );

      addWatermark(doc, dpageWidth, dpageHeight, watermarkLogoDataUrl);
    }
  }

  // ============ SHOPPING LIST PAGE ============
  doc.addPage('portrait');
  y = margin + 20;

  setPdfFontSize(doc, 18);
  doc.setFont('helvetica', 'bold');
  doc.setTextColor(0, 0, 0);
  doc.text('Shopping List', margin, y);
  y += 30;

  // Lumber section
  setPdfFontSize(doc, 12);
  doc.setFont('helvetica', 'bold');
  doc.text('Lumber & Sheet Goods', margin, y);
  y += 20;

  doc.setFillColor(240, 240, 240);
  doc.rect(margin, y - 12, contentWidth, 18, 'F');
  setPdfFontSize(doc, 9);
  doc.text('\u2610', margin + 5, y);
  doc.text('Stock', margin + 20, y);
  doc.text('Dimensions', margin + 162, y);
  doc.text('Qty', margin + 314, y);
  doc.text('Unit Price', margin + 362, y);
  doc.text('Total', margin + 452, y);
  y += 18;

  doc.setFont('helvetica', 'normal');

  for (const summary of cutList.statistics.byStock) {
    if (y > pageHeight - 100) {
      addWatermark(doc, pageWidth, pageHeight, watermarkLogoDataUrl);
      doc.addPage();
      y = margin + 20;
    }

    const dims = `${formatMeasurementWithUnit(summary.stockLength, units)} x ${formatMeasurementWithUnit(summary.stockWidth, units)} x ${formatMeasurementWithUnit(summary.stockThickness, units)}`;
    const unitPrice =
      summary.pricingUnit === 'board_foot'
        ? `$${summary.pricePerUnit.toFixed(2)}/bf`
        : `$${summary.pricePerUnit.toFixed(2)}/ea`;

    drawChecklistBox(doc, margin + 5, y, 7);
    doc.text(summary.stockName, margin + 20, y);
    doc.text(dims, margin + 162, y);
    doc.text(summary.boardsNeeded.toString(), margin + 314, y);
    doc.text(unitPrice, margin + 362, y);
    doc.text(`$${summary.cost.toFixed(2)}`, margin + 452, y);
    y += 16;
  }

  y += 5;
  doc.setFont('helvetica', 'bold');
  doc.text('Subtotal:', margin + 370, y);
  doc.text(`$${cutList.statistics.estimatedCost.toFixed(2)}`, margin + 450, y);
  y += 25;

  // Custom items
  if (customShoppingItems.length > 0) {
    setPdfFontSize(doc, 12);
    doc.text('Other Items', margin, y);
    y += 20;

    doc.setFillColor(240, 240, 240);
    doc.rect(margin, y - 12, contentWidth, 18, 'F');
    setPdfFontSize(doc, 9);
    doc.text('\u2610', margin + 5, y);
    doc.text('Item', margin + 20, y);
    doc.text('Description', margin + 178, y);
    doc.text('Qty', margin + 314, y);
    doc.text('Unit Price', margin + 362, y);
    doc.text('Total', margin + 452, y);
    y += 18;

    doc.setFont('helvetica', 'normal');

    for (const item of customShoppingItems) {
      if (y > pageHeight - 80) {
        addWatermark(doc, pageWidth, pageHeight, watermarkLogoDataUrl);
        doc.addPage();
        y = margin + 20;
      }

      const itemTotal = item.quantity * item.unitPrice;
      drawChecklistBox(doc, margin + 5, y, 7);
      doc.text(item.name, margin + 20, y);
      doc.text(item.description || '', margin + 178, y);
      doc.text(item.quantity.toString(), margin + 314, y);
      doc.text(`$${item.unitPrice.toFixed(2)}`, margin + 362, y);
      doc.text(`$${itemTotal.toFixed(2)}`, margin + 452, y);
      y += 16;
    }

    y += 5;
    doc.setFont('helvetica', 'bold');
    const otherTotal = customShoppingItems.reduce((sum, item) => sum + item.quantity * item.unitPrice, 0);
    doc.text('Subtotal:', margin + 370, y);
    doc.text(`$${otherTotal.toFixed(2)}`, margin + 450, y);
    y += 25;
  }

  // Grand total
  setPdfFontSize(doc, 11);
  doc.setFillColor(230, 230, 230);
  doc.rect(margin + 300, y - 12, contentWidth - 300, 22, 'F');
  doc.text('GRAND TOTAL:', margin + 340, y + 2);
  doc.text(`$${grandTotal.toFixed(2)}`, margin + 450, y + 2);

  addWatermark(doc, pageWidth, pageHeight, watermarkLogoDataUrl);

  // Save
  try {
    const defaultFileName = `${projectName || 'project'}-report.pdf`;
    const result = await window.electronAPI.showSaveDialog({
      defaultPath: defaultFileName,
      filters: [{ name: 'PDF Files', extensions: ['pdf'] }]
    });

    if (result.canceled || !result.filePath) {
      return { success: false, canceled: true };
    }

    const pdfArrayBuffer = doc.output('arraybuffer');
    const uint8Array = new Uint8Array(pdfArrayBuffer);
    const numberArray = Array.from(uint8Array);

    await window.electronAPI.writeBinaryFile(result.filePath, numberArray);

    return { success: true, filePath: result.filePath };
  } catch (error) {
    logger.error('Project report PDF export error:', error);
    return { success: false, error: String(error) };
  }
}

/**
 * Export cutting diagrams to PDF
 * Draws each stock board with its placed parts
 */
export async function exportDiagramsToPdf(
  cutList: CutList,
  options: ExportOptions
): Promise<{ success: boolean; filePath?: string; error?: string; canceled?: boolean }> {
  const { projectName, units } = options;

  // Group boards by stock
  const boardsByStock = new Map<string, StockBoard[]>();
  for (const board of cutList.stockBoards) {
    const existing = boardsByStock.get(board.stockId) || [];
    existing.push(board);
    boardsByStock.set(board.stockId, existing);
  }

  const diagramMargin = 40;
  const diagramHeaderHeight = 22;
  const diagramFooterReserve = 20;
  const allBoards = Array.from(boardsByStock.values()).flat();

  // Choose the best orientation for the first diagram page.
  const firstLayout =
    allBoards.length > 0
      ? getBestDiagramLayout(allBoards[0], diagramMargin, diagramHeaderHeight, diagramFooterReserve)
      : { pageOrientation: 'landscape' as const, rotateBoard: false };

  const doc = new jsPDF({
    orientation: firstLayout.pageOrientation,
    unit: 'pt', // points for precise positioning
    format: 'letter'
  });

  const pageWidth = doc.internal.pageSize.getWidth();
  const pageHeight = doc.internal.pageSize.getHeight();
  const watermarkLogoDataUrl = await getWatermarkLogoDataUrl();

  // Draw each stock board (one board per page, orientation optimized for readability)
  allBoards.forEach((board, index) => {
    const layout = getBestDiagramLayout(board, diagramMargin, diagramHeaderHeight, diagramFooterReserve);
    if (index > 0) {
      doc.addPage(layout.pageOrientation);
    }

    const currentPageWidth = doc.internal.pageSize.getWidth();
    const currentPageHeight = doc.internal.pageSize.getHeight();
    const contentWidth = currentPageWidth - diagramMargin * 2;
    const contentHeight = currentPageHeight - diagramMargin * 2 - diagramFooterReserve;

    drawBoardDiagram(
      doc,
      board,
      board.stockName,
      units,
      {
        x: diagramMargin,
        y: diagramMargin,
        width: contentWidth,
        height: contentHeight
      },
      {
        rotateBoard: layout.rotateBoard,
        title: `${projectName} - ${buildBoardLabel(board)} - ${board.stockName} (Board #${board.boardIndex})`
      }
    );

    addWatermark(doc, currentPageWidth, currentPageHeight, watermarkLogoDataUrl);
  });

  if (allBoards.length === 0) {
    setPdfFontSize(doc, 16);
    doc.setFont('helvetica', 'bold');
    doc.setTextColor(0, 0, 0);
    doc.text(`${projectName} - Cutting Diagrams`, diagramMargin, diagramMargin + 20);
    setPdfFontSize(doc, 10);
    doc.setFont('helvetica', 'normal');
    doc.text('No diagrams available for export.', diagramMargin, diagramMargin + 42);
    addWatermark(doc, pageWidth, pageHeight, watermarkLogoDataUrl);
  }

  // Show save dialog and save
  try {
    const defaultFileName = `${projectName || 'Untitled'}-cutting-diagrams.pdf`;
    const result = await window.electronAPI.showSaveDialog({
      defaultPath: defaultFileName,
      filters: [{ name: 'PDF Files', extensions: ['pdf'] }]
    });

    if (result.canceled || !result.filePath) {
      return { success: false, canceled: true };
    }

    // Convert PDF to array buffer and save as binary
    const pdfArrayBuffer = doc.output('arraybuffer');
    const uint8Array = new Uint8Array(pdfArrayBuffer);
    const numberArray = Array.from(uint8Array);

    await window.electronAPI.writeBinaryFile(result.filePath, numberArray);

    return { success: true, filePath: result.filePath };
  } catch (error) {
    logger.error('PDF export error:', error);
    return { success: false, error: String(error) };
  }
}

/**
 * Export cut list to CSV with watermark header
 */
export function exportCutListToCsv(cutList: CutList, units: 'imperial' | 'metric'): string {
  const grouped = groupCutInstructions(cutList.instructions);
  const partBoardMap = buildPartBoardMap(cutList.stockBoards);
  const unitLabel = units === 'imperial' ? 'inches' : 'mm';

  const rows = [
    getCsvHeader(),
    'CUT LIST',
    `Units: ${unitLabel}`,
    '',
    [
      'Qty',
      'Cut Length',
      'Cut Width',
      'Thickness',
      'Stock',
      'Stock ID',
      'Board IDs',
      'Part IDs',
      'Part Names',
      'Group Path',
      'Grain Sensitive',
      'Glue-Up'
    ].join(',')
  ];

  for (const group of grouped) {
    const partNames = group.items.map((i) => i.partName).join('; ');
    const partIds = group.items.map((i) => i.partId).join('; ');
    const boardIds = Array.from(new Set(group.items.flatMap((i) => Array.from(partBoardMap.get(i.partId) ?? [])))).join(
      '; '
    );
    const groupPath = ''; // Reserved for nested group-chain export when path metadata is available in cut instructions.
    rows.push(
      [
        group.quantity.toString(),
        csvEscape(formatMeasurementWithUnit(group.cutLength, units)),
        csvEscape(formatMeasurementWithUnit(group.cutWidth, units)),
        csvEscape(formatMeasurementWithUnit(group.thickness, units)),
        csvEscape(group.stockName),
        csvEscape(group.stockId),
        csvEscape(boardIds),
        csvEscape(partIds),
        csvEscape(partNames),
        csvEscape(groupPath),
        group.grainSensitive ? 'Yes' : 'No',
        group.isGlueUp ? 'Yes' : 'No'
      ].join(',')
    );
  }

  return rows.join('\n');
}

/**
 * Export shopping list to CSV with watermark header
 */
export function exportShoppingListToCsv(
  cutList: CutList,
  customShoppingItems: CustomShoppingItem[],
  units: 'imperial' | 'metric'
): string {
  const unitLabel = units === 'imperial' ? 'inches' : 'mm';
  const lines = [
    getCsvHeader(),
    'SHOPPING LIST',
    `Units: ${unitLabel}`,
    '',
    'LUMBER & SHEET GOODS',
    'Stock,Stock ID,Dimensions,Quantity,Actual Boards Used,Avg Utilization %,Waste Sq In,Unit Price,Total'
  ];

  for (const summary of cutList.statistics.byStock) {
    const dims = `${formatMeasurementWithUnit(summary.stockLength, units)} x ${formatMeasurementWithUnit(summary.stockWidth, units)} x ${formatMeasurementWithUnit(summary.stockThickness, units)}`;
    const unitPrice =
      summary.pricingUnit === 'board_foot'
        ? `$${summary.pricePerUnit.toFixed(2)}/bf`
        : `$${summary.pricePerUnit.toFixed(2)}/ea`;
    lines.push(
      [
        csvEscape(summary.stockName),
        csvEscape(summary.stockId),
        csvEscape(dims),
        summary.boardsNeeded,
        summary.actualBoardsUsed,
        summary.averageUtilization.toFixed(1),
        summary.wasteSquareInches.toFixed(2),
        unitPrice,
        `$${summary.cost.toFixed(2)}`
      ].join(',')
    );
  }

  lines.push(`Lumber Subtotal,,,,,,,,$${cutList.statistics.estimatedCost.toFixed(2)}`);

  if (customShoppingItems.length > 0) {
    lines.push('');
    lines.push('OTHER ITEMS');
    lines.push('Item,Item ID,Category,Description,Quantity,Unit Price,Total');

    let customTotal = 0;
    for (const item of customShoppingItems) {
      const itemTotal = item.quantity * item.unitPrice;
      customTotal += itemTotal;
      lines.push(
        [
          csvEscape(item.name),
          csvEscape(item.id),
          csvEscape(item.category || ''),
          csvEscape(item.description || ''),
          item.quantity,
          `$${item.unitPrice.toFixed(2)}`,
          `$${itemTotal.toFixed(2)}`
        ].join(',')
      );
    }

    lines.push(`Other Items Subtotal,,,,,,$${customTotal.toFixed(2)}`);
  }

  const customTotal = customShoppingItems.reduce((sum, item) => sum + item.quantity * item.unitPrice, 0);
  const grandTotal = cutList.statistics.estimatedCost + customTotal;

  lines.push('');
  lines.push(`GRAND TOTAL,,,,,,$${grandTotal.toFixed(2)}`);

  return lines.join('\n');
}
